---
title: "JavaScript Type Nuances"
sidebarTitle: "Type Nuances"
description: "Learn JavaScript type nuances: null vs undefined, typeof quirks, nullish coalescing (??), optional chaining (?.), Symbols, and BigInt for large integers."
"og:type": "article"
"article:author": "Leonardo Maldonado"
"article:section": "Type System"
"article:tag": "javascript types, typeof operator, null undefined, nullish coalescing, optional chaining, bigint symbols"
---

Why does `typeof null` return `'object'`? Why does `0 || 'default'` give you `'default'` when `0` is a perfectly valid value? And why do Symbols exist when we already have strings for object keys?

```javascript
// JavaScript's type system has quirks you need to know
let user              // undefined — not initialized
let data = null       // null — intentionally empty

typeof null           // 'object' — a famous bug!
typeof undefined      // 'undefined'

0 || 'fallback'       // 'fallback' — but 0 is valid!
0 ?? 'fallback'       // 0 — nullish coalescing saves the day

const id = Symbol('id')  // Unique, collision-proof key
const huge = 9007199254740993n  // BigInt for precision
```

JavaScript's type system is full of these nuances. Understanding them separates developers who write predictable code from those who constantly debug mysterious behavior.

<Info>
**What you'll learn in this guide:**
- The difference between `null` and `undefined` (and when to use each)
- Short-circuit evaluation with `&&`, `||`, `??`, and `?.`
- The `typeof` operator's quirks and edge cases
- How `instanceof` works and how to customize it with `Symbol.hasInstance`
- Symbols for creating unique identifiers and well-known symbols
- BigInt for working with numbers beyond JavaScript's safe integer limit
</Info>

<Warning>
**Prerequisites:** This guide assumes you understand [Primitive Types](/concepts/primitive-types) and [Type Coercion](/concepts/type-coercion). If you're not comfortable with JavaScript's basic types and how they convert, read those guides first.
</Warning>

---

## What are JavaScript Type Nuances?

**JavaScript type nuances** are the subtle behaviors, quirks, and advanced features of JavaScript's type system that go beyond basic types. They include the semantic differences between `null` and `undefined`, the historical quirks of the [`typeof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) operator, modern operators like [nullish coalescing](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) (`??`), and primitive types like [`Symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) and [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) that solve specific problems.

---

## JavaScript is Dynamically Typed

Before diving into type nuances, it's important to understand that **JavaScript is a dynamically typed language**. Unlike statically typed languages like TypeScript, Rust, Java, or C++, JavaScript doesn't require you to declare variable types, and types are checked at runtime rather than compile time.

```javascript
// In JavaScript, variables can hold any type and change types freely
let value = 42           // value is a number
value = 'hello'          // now it's a string
value = { name: 'Alice' } // now it's an object
value = null             // now it's null

// No compiler errors — JavaScript figures out types at runtime
```

This flexibility is both powerful and dangerous:

```javascript
// TypeScript / Rust / Java would catch this at compile time:
function add(a, b) {
  return a + b
}

add(5, 3)        // 8 — works as expected
add('5', 3)      // '53' — string concatenation, not addition!
add(null, 3)     // 3 — null becomes 0
add(undefined, 3) // NaN — undefined becomes NaN
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│              STATIC vs DYNAMIC TYPING COMPARISON                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  STATICALLY TYPED                      DYNAMICALLY TYPED                 │
│  (TypeScript, Rust, Java)              (JavaScript, Python, Ruby)        │
│  ─────────────────────────             ──────────────────────────        │
│                                                                          │
│  • Types declared explicitly           • Types inferred at runtime       │
│  • Type errors caught at compile       • Type errors occur at runtime    │
│  • Variables have fixed types          • Variables can change types      │
│  • More verbose, safer                 • More flexible, riskier          │
│                                                                          │
│  let name: string = "Alice"            let name = "Alice"                │
│  name = 42  // ❌ Compile error        name = 42  // ✓ No error          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

Because JavaScript won't stop you from mixing types, **you need to understand how types behave** — which is exactly what this guide covers. The `typeof` operator, type coercion, and operators like `??` and `?.` exist specifically to help you handle JavaScript's dynamic nature safely.

<Note>
**TypeScript adds static typing to JavaScript.** If you want compile-time type safety, TypeScript is an excellent choice. But even TypeScript compiles to JavaScript, so understanding JavaScript's runtime type behavior is essential for all JavaScript developers.
</Note>

---

## The Empty Box Analogy

Think of variables like boxes:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    UNDEFINED vs NULL: THE BOX ANALOGY                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   UNDEFINED                              NULL                            │
│   ─────────                              ────                            │
│                                                                          │
│   ┌─────────────┐                       ┌─────────────┐                  │
│   │             │                       │             │                  │
│   │     ???     │                       │   [empty]   │                  │
│   │             │                       │             │                  │
│   └─────────────┘                       └─────────────┘                  │
│                                                                          │
│   "What box? I never                    "Here's an empty box.            │
│    put anything here!"                   I'm telling you there's         │
│                                          nothing inside on purpose."     │
│                                                                          │
│   • Variable declared but not assigned  • Variable intentionally set     │
│   • Missing object property             • Represents "no value"          │
│   • Function returns nothing            • End of prototype chain         │
│   • Missing function parameter          • Cleared reference              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**undefined** means the box was never filled. **null** means someone deliberately put an empty placeholder in the box. This distinction matters for writing clear, intentional code.

---

## null vs undefined: The Two Kinds of "Nothing"

JavaScript is unique among programming languages in having two representations for "no value." Understanding when JavaScript uses each helps you write more predictable code.

### When JavaScript Returns undefined

JavaScript returns [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) automatically in these situations:

```javascript
// 1. Variables declared but not initialized
let name
console.log(name)  // undefined

// 2. Missing object properties
const user = { name: 'Alice' }
console.log(user.age)  // undefined

// 3. Functions that don't return anything
function greet() {
  console.log('Hello!')
  // no return statement
}
console.log(greet())  // undefined

// 4. Missing function parameters
function sayHi(name) {
  console.log(name)
}
sayHi()  // undefined

// 5. Array holes
const sparse = [1, , 3]
console.log(sparse[1])  // undefined
```

### When to Use null

Use [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null) when you want to explicitly indicate "no value" or "empty":

```javascript
// 1. Intentionally clearing a value
let currentUser = { name: 'Alice' }
currentUser = null  // User logged out

// 2. API responses for missing data
const response = {
  user: null,  // User not found, but the field exists
  error: null  // No error occurred
}

// 3. DOM methods that find nothing
document.querySelector('.nonexistent')  // null

// 4. End of prototype chain
Object.getPrototypeOf(Object.prototype)  // null

// 5. Optional parameters with default values
function createUser(name, email = null) {
  return { name, email }  // email is explicitly optional
}
```

### Comparing null and undefined

Here's how these values behave in different contexts:

| Operation | `null` | `undefined` |
|-----------|--------|-------------|
| `typeof` | `'object'` (bug!) | `'undefined'` |
| `== null` | `true` | `true` |
| `=== null` | `true` | `false` |
| `Boolean()` | `false` | `false` |
| `Number()` | `0` | `NaN` |
| `String()` | `'null'` | `'undefined'` |
| `JSON.stringify()` | `null` | omitted |

```javascript
// The equality quirk
null == undefined   // true (loose equality)
null === undefined  // false (strict equality)

// Type checking differences
typeof null         // 'object' — historical bug!
typeof undefined    // 'undefined'

// Numeric coercion
null + 1            // 1 (null becomes 0)
undefined + 1       // NaN (undefined becomes NaN)

// JSON serialization
JSON.stringify({ a: null, b: undefined })
// '{"a":null}' — undefined properties are skipped!
```

### Checking for Both

To check if a value is either `null` or `undefined`, you have several options:

```javascript
const value = getSomeValue()

// Option 1: Loose equality (catches both null and undefined)
if (value == null) {
  console.log('No value')
}

// Option 2: Explicit check
if (value === null || value === undefined) {
  console.log('No value')
}

// Option 3: Nullish coalescing for defaults
const result = value ?? 'default'  // Only triggers for null/undefined
```

<Tip>
**Quick Rule:** Use `== null` to check for both `null` and `undefined` in one shot. This is one of the few cases where loose equality is preferred over strict equality.
</Tip>

---

## Short-Circuit Evaluation: && || ?? and ?.

JavaScript's logical operators don't just return `true` or `false`. They return the actual value that determined the result. Understanding this unlocks powerful patterns.

### Logical OR (||) — First Truthy Value

The [`||`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR) operator returns the first [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) value, or the last value if none are truthy:

```javascript
// Returns the first truthy value
'hello' || 'default'   // 'hello'
'' || 'default'        // 'default' (empty string is falsy)
0 || 42                // 42 (0 is falsy!)
null || 'fallback'     // 'fallback'
undefined || 'fallback' // 'fallback'

// Common pattern: default values
const username = user.name || 'Anonymous'
const port = config.port || 3000
```

The problem with `||` is it treats **all falsy values** as triggers for the fallback:

```javascript
// Falsy values: false, 0, '', null, undefined, NaN

// This might not do what you want!
const count = userCount || 10   // If userCount is 0, you get 10!
const name = userName || 'Guest' // If userName is '', you get 'Guest'!
```

### Logical AND (&&) — First Falsy Value

The [`&&`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND) operator returns the first falsy value, or the last value if all are truthy:

```javascript
// Returns the first falsy value
true && 'hello'        // 'hello' (both truthy, returns last)
'hello' && 42          // 42
null && 'hello'        // null (first falsy)
0 && 'hello'           // 0 (first falsy)

// Common pattern: conditional execution
user && user.name      // Only access name if user exists
isAdmin && deleteButton.show()  // Only call if isAdmin is truthy
```

### Nullish Coalescing (??) — Only null/undefined

The [`??`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) operator is the modern solution. It only falls back when the left side is `null` or `undefined`:

```javascript
// Only null and undefined trigger the fallback
0 ?? 42           // 0 (0 is NOT nullish!)
'' ?? 'default'   // '' (empty string is NOT nullish!)
false ?? true     // false
null ?? 'fallback'     // 'fallback'
undefined ?? 'fallback' // 'fallback'

// Now you can safely use 0 and '' as valid values
const count = userCount ?? 10   // 0 stays as 0
const name = userName ?? 'Guest' // '' stays as ''
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          || vs ?? COMPARISON                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   EXPRESSION              ||               ??                            │
│   ──────────              ──               ──                            │
│                                                                          │
│   0 || 42                 42               0                             │
│   '' || 'default'         'default'        ''                            │
│   false || true           true             false                         │
│   NaN || 0                0                NaN                           │
│   null || 'fallback'      'fallback'       'fallback'                    │
│   undefined || 'fallback' 'fallback'       'fallback'                    │
│                                                                          │
│   KEY DIFFERENCE:                                                        │
│   || triggers on ANY falsy value (false, 0, '', null, undefined, NaN)   │
│   ?? triggers ONLY on null or undefined                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

<Warning>
**Heads up:** You cannot mix `??` with `&&` or `||` without parentheses. JavaScript throws a `SyntaxError` to prevent ambiguity:

```javascript
// ❌ SyntaxError
null || undefined ?? 'default'

// ✓ Use parentheses to clarify intent
(null || undefined) ?? 'default'  // 'default'
null || (undefined ?? 'default')  // 'default'
```
</Warning>

### Optional Chaining (?.) — Safe Property Access

The [`?.`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) operator stops evaluation if the left side is `null` or `undefined`, returning `undefined` instead of throwing an error:

```javascript
const user = {
  name: 'Alice',
  address: {
    city: 'Wonderland'
  }
}

// Without optional chaining — verbose and error-prone
const city = user && user.address && user.address.city

// With optional chaining — clean and safe
const city = user?.address?.city  // 'Wonderland'

// Works with missing properties
const nullUser = null
nullUser?.name           // undefined (no error!)
nullUser?.address?.city  // undefined (no error!)

// Works with arrays
const users = [{ name: 'Alice' }]
users?.[0]?.name  // 'Alice'
users?.[99]?.name // undefined

// Works with function calls
const api = {
  getUser: () => ({ name: 'Alice' })
}
api.getUser?.()           // { name: 'Alice' }
api.nonexistent?.()       // undefined (no error!)
```

### Combining ?? and ?.

These operators work beautifully together:

```javascript
// Get deeply nested value with a default
const theme = user?.settings?.theme ?? 'light'

// Safe function call with default return
const result = api.getData?.() ?? []

// Real-world example: configuration
const config = {
  api: {
    // timeout might be intentionally set to 0
  }
}

const timeout = config?.api?.timeout ?? 5000  // 5000 (no timeout set)

// If timeout was 0:
config.api.timeout = 0
const timeout2 = config?.api?.timeout ?? 5000  // 0 (respects the explicit 0)
```

---

## The typeof Operator and Its Quirks

The [`typeof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) operator returns a string indicating the type of a value. It's useful, but has some surprising behaviors.

### Basic Usage

```javascript
// Primitives
typeof 'hello'      // 'string'
typeof 42           // 'number'
typeof 42n          // 'bigint'
typeof true         // 'boolean'
typeof undefined    // 'undefined'
typeof Symbol('id') // 'symbol'

// Objects and functions
typeof {}           // 'object'
typeof []           // 'object' (arrays are objects!)
typeof new Date()   // 'object'
typeof /regex/      // 'object'
typeof function(){} // 'function' (special case)
typeof class {}     // 'function' (classes are functions)
```

### The typeof null Bug

This is JavaScript's most famous quirk:

```javascript
typeof null  // 'object' — NOT 'null'!
```

This is a bug from the first version of JavaScript in 1995. In the original implementation, values were stored with a type tag. Objects had a type tag of `0`. `null` was represented as the NULL pointer (`0x00`), which also had a type tag of `0`. So `typeof null` returned `'object'`.

Fixing this bug would break too much existing code, so it remains. To properly check for `null`:

```javascript
// ❌ Wrong — typeof doesn't work for null
if (typeof value === 'null') { }  // Never true!

// ✓ Correct — direct comparison
if (value === null) { }

// ✓ Also correct — check both null and undefined
if (value == null) { }
```

### typeof with Undeclared Variables

Unlike most operations, `typeof` doesn't throw an error for undeclared variables:

```javascript
// This would throw ReferenceError
console.log(undeclaredVar)  // ReferenceError: undeclaredVar is not defined

// But typeof returns 'undefined' safely
typeof undeclaredVar  // 'undefined'

// Useful for feature detection
if (typeof window !== 'undefined') {
  // Running in a browser
}

if (typeof process !== 'undefined') {
  // Running in Node.js
}
```

### typeof with the Temporal Dead Zone

However, `typeof` does throw for `let`/`const` variables accessed before declaration:

```javascript
// let and const create a Temporal Dead Zone (TDZ)
console.log(typeof myVar)  // ReferenceError!
let myVar = 'hello'

// This is because the variable exists but isn't initialized yet
// See the Temporal Dead Zone guide for more details
```

### Complete typeof Return Values

| Value | `typeof` Result |
|-------|-----------------|
| `undefined` | `'undefined'` |
| `null` | `'object'` (bug) |
| `true` / `false` | `'boolean'` |
| Any number | `'number'` |
| Any BigInt | `'bigint'` |
| Any string | `'string'` |
| Any Symbol | `'symbol'` |
| Any function | `'function'` |
| Any other object | `'object'` |

### Better Type Checking

For more precise type checking, use these patterns:

```javascript
// Check for array
Array.isArray([1, 2, 3])  // true
Array.isArray('hello')    // false

// Check for null specifically
value === null

// Check for plain objects
Object.prototype.toString.call({})        // '[object Object]'
Object.prototype.toString.call([])        // '[object Array]'
Object.prototype.toString.call(null)      // '[object Null]'
Object.prototype.toString.call(undefined) // '[object Undefined]'
Object.prototype.toString.call(new Date()) // '[object Date]'

// Helper function for precise type checking
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
}

getType(null)        // 'null'
getType([])          // 'array'
getType({})          // 'object'
getType(new Date())  // 'date'
getType(/regex/)     // 'regexp'
```

---

## instanceof and Symbol.hasInstance

While `typeof` checks primitive types, [`instanceof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) checks if an object was created by a specific constructor or class.

### How instanceof Works

```javascript
class Animal {}
class Dog extends Animal {}

const buddy = new Dog()

buddy instanceof Dog     // true
buddy instanceof Animal  // true (inheritance chain)
buddy instanceof Object  // true (everything inherits from Object)
buddy instanceof Array   // false

// Works with built-in constructors too
[] instanceof Array      // true
{} instanceof Object     // true
new Date() instanceof Date // true
/regex/ instanceof RegExp  // true

// But not with primitives!
'hello' instanceof String  // false (primitive, not String object)
42 instanceof Number       // false (primitive, not Number object)
```

### instanceof Checks the Prototype Chain

`instanceof` works by checking if the constructor's `prototype` property exists anywhere in the object's prototype chain:

```javascript
class Animal {
  speak() { return 'Some sound' }
}

class Dog extends Animal {
  speak() { return 'Woof!' }
}

const buddy = new Dog()

// instanceof checks if Dog.prototype is in buddy's chain
Dog.prototype.isPrototypeOf(buddy)     // true
Animal.prototype.isPrototypeOf(buddy)  // true

// You can break instanceof by reassigning prototype
Dog.prototype = {}
buddy instanceof Dog  // false now!
```

### Customizing instanceof with Symbol.hasInstance

You can customize how `instanceof` behaves using [`Symbol.hasInstance`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance):

```javascript
// Custom class that considers any object with a 'quack' method a Duck
class Duck {
  static [Symbol.hasInstance](instance) {
    return instance?.quack !== undefined
  }
}

const mallard = { quack: () => 'Quack!' }
const dog = { bark: () => 'Woof!' }

mallard instanceof Duck  // true (has quack method)
dog instanceof Duck      // false (no quack method)

// Real-world example: validating data shapes
class ValidUser {
  static [Symbol.hasInstance](obj) {
    return obj !== null &&
           typeof obj === 'object' &&
           typeof obj.id === 'number' &&
           typeof obj.email === 'string'
  }
}

const user = { id: 1, email: 'alice@example.com' }
const invalid = { name: 'Bob' }

user instanceof ValidUser    // true
invalid instanceof ValidUser // false
```

### instanceof vs typeof

| Check | Use `typeof` | Use `instanceof` |
|-------|-------------|------------------|
| Is it a string? | `typeof x === 'string'` | ❌ (primitives fail) |
| Is it a number? | `typeof x === 'number'` | ❌ (primitives fail) |
| Is it an array? | ❌ (returns 'object') | `x instanceof Array` or `Array.isArray(x)` |
| Is it a Date? | ❌ (returns 'object') | `x instanceof Date` |
| Is it a custom class? | ❌ | `x instanceof MyClass` |

---

## Symbols: Unique Identifiers

[`Symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) is a primitive type that creates guaranteed unique identifiers. Every `Symbol()` call creates a new, unique value.

### Creating Symbols

```javascript
// Create symbols with optional descriptions
const id = Symbol('id')
const anotherId = Symbol('id')

// Every symbol is unique!
id === anotherId  // false (different symbols)
id === id         // true (same symbol)

// The description is just for debugging
console.log(id)          // Symbol(id)
console.log(id.description) // 'id'
```

### Using Symbols as Object Keys

Symbols solve the problem of property name collisions:

```javascript
// Problem: property name collision
const user = {
  id: 123,
  name: 'Alice'
}

// A library might want to add its own 'id' — collision!
user.id = 'library-internal-id'  // Oops, overwrote the user's id!

// Solution: use a Symbol
const internalId = Symbol('internal-id')
user[internalId] = 'library-internal-id'

console.log(user.id)         // 123 (original preserved)
console.log(user[internalId]) // 'library-internal-id'

// Symbols are hidden from normal iteration
Object.keys(user)        // ['id', 'name'] — no symbol!
JSON.stringify(user)     // '{"id":123,"name":"Alice"}' — no symbol!

// But you can still access them
Object.getOwnPropertySymbols(user)  // [Symbol(internal-id)]
```

### Global Symbol Registry

Use `Symbol.for()` to create symbols that can be shared across files or even iframes:

```javascript
// Create or retrieve a global symbol
const globalId = Symbol.for('app.userId')

// Same key returns the same symbol
const sameId = Symbol.for('app.userId')
globalId === sameId  // true

// Get the key from a global symbol
Symbol.keyFor(globalId)  // 'app.userId'

// Regular symbols aren't in the registry
const localId = Symbol('local')
Symbol.keyFor(localId)  // undefined
```

### Well-Known Symbols

JavaScript has built-in symbols that let you customize object behavior:

```javascript
// Symbol.iterator — make objects iterable
const range = {
  start: 1,
  end: 5,
  [Symbol.iterator]() {
    let current = this.start
    const end = this.end
    return {
      next() {
        if (current <= end) {
          return { value: current++, done: false }
        }
        return { done: true }
      }
    }
  }
}

for (const num of range) {
  console.log(num)  // 1, 2, 3, 4, 5
}

// Symbol.toStringTag — customize Object.prototype.toString
class MyClass {
  get [Symbol.toStringTag]() {
    return 'MyClass'
  }
}

Object.prototype.toString.call(new MyClass())  // '[object MyClass]'

// Symbol.toPrimitive — customize type conversion
const money = {
  amount: 100,
  currency: 'USD',
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') return this.amount
    if (hint === 'string') return `${this.currency} ${this.amount}`
    return this.amount
  }
}

+money       // 100 (hint: 'number')
`${money}`   // 'USD 100' (hint: 'string')
```

### Common Well-Known Symbols

| Symbol | Purpose |
|--------|---------|
| `Symbol.iterator` | Define how to iterate over an object |
| `Symbol.asyncIterator` | Define async iteration |
| `Symbol.toStringTag` | Customize `[object X]` output |
| `Symbol.toPrimitive` | Customize type conversion |
| `Symbol.hasInstance` | Customize `instanceof` behavior |
| `Symbol.isConcatSpreadable` | Control `Array.concat` spreading |

---

## BigInt: Numbers Beyond the Limit

Regular JavaScript numbers have a precision limit. [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) lets you work with integers of any size.

### The Precision Problem

```javascript
// JavaScript numbers are 64-bit floating point
// They can only safely represent integers up to 2^53 - 1

console.log(Number.MAX_SAFE_INTEGER)  // 9007199254740991

// Beyond this, precision is lost
9007199254740992 === 9007199254740993  // true! (they're the same to JS)

// This causes real problems
const twitterId = 9007199254740993
console.log(twitterId)  // 9007199254740992 — wrong!
```

### Creating BigInt Values

```javascript
// Add 'n' suffix to number literals
const big = 9007199254740993n
console.log(big)  // 9007199254740993n — correct!

// Or use the BigInt() function
const alsoBig = BigInt('9007199254740993')
const fromNumber = BigInt(42)  // Only safe for integers within safe range

// BigInt preserves precision
9007199254740992n === 9007199254740993n  // false (correctly different!)
```

### BigInt Operations

```javascript
const a = 10n
const b = 3n

// Arithmetic works as expected
a + b    // 13n
a - b    // 7n
a * b    // 30n
a ** b   // 1000n

// Division truncates (no decimals)
a / b    // 3n (not 3.333...)

// Remainder
a % b    // 1n

// Comparison
a > b    // true
a === 10n // true
```

### BigInt Limitations

```javascript
// ❌ Cannot mix BigInt and Number in operations
10n + 5   // TypeError: Cannot mix BigInt and other types

// ✓ Convert explicitly
10n + BigInt(5)  // 15n
Number(10n) + 5  // 15 (but may lose precision for large values!)

// ❌ Cannot use with Math methods
Math.max(1n, 2n)  // TypeError

// ✓ Compare using > < instead
1n > 2n ? 1n : 2n  // 2n

// ❌ Cannot use unary +
+10n  // TypeError

// ✓ Use Number() or just use the value
Number(10n)  // 10

// BigInt in JSON
JSON.stringify({ id: 10n })  // TypeError: BigInt value can't be serialized

// ✓ Convert to string first
JSON.stringify({ id: 10n.toString() })  // '{"id":"10"}'
```

### When to Use BigInt

```javascript
// 1. Working with large IDs (Twitter, Discord, etc.)
const tweetId = 1234567890123456789n

// 2. Cryptographic operations
const largeKey = 2n ** 256n

// 3. Financial calculations requiring exact integers
// (though for money, usually use integers in cents, not BigInt)
const worldDebt = 300_000_000_000_000n  // $300 trillion in dollars

// 4. When you need arbitrary precision
function factorial(n) {
  if (n <= 1n) return 1n
  return n * factorial(n - 1n)
}
factorial(100n)  // Huge number, no precision loss!
```

<Note>
**When NOT to use BigInt:** For normal integer operations within JavaScript's safe range (±9 quadrillion), regular numbers are faster and more convenient. Only reach for BigInt when you actually need values beyond `Number.MAX_SAFE_INTEGER`.
</Note>

---

## Common Mistakes

<AccordionGroup>
  <Accordion title="Using || when you need ??">
    The `||` operator treats `0`, `''`, and `false` as falsy, which might not be what you want:
    
    ```javascript
    // ❌ Wrong — loses valid values
    const count = userCount || 10   // If userCount is 0, you get 10!
    const name = userName || 'Guest' // If userName is '', you get 'Guest'!
    
    // ✓ Correct — only fallback on null/undefined
    const count = userCount ?? 10   // 0 stays as 0
    const name = userName ?? 'Guest' // '' stays as ''
    ```
  </Accordion>
  
  <Accordion title="Using typeof to check for null">
    `typeof null` returns `'object'`, not `'null'`:
    
    ```javascript
    // ❌ Wrong — never works
    if (typeof value === 'null') {
      // This block never executes!
    }
    
    // ✓ Correct — direct comparison
    if (value === null) {
      // This works
    }
    ```
  </Accordion>
  
  <Accordion title="Mixing BigInt and Number in operations">
    You can't use `+`, `-`, `*`, `/` between BigInt and Number:
    
    ```javascript
    // ❌ TypeError
    10n + 5
    BigInt(10) * 3
    
    // ✓ Convert to the same type first
    10n + BigInt(5)  // 15n
    Number(10n) + 5  // 15
    ```
  </Accordion>
  
  <Accordion title="Expecting instanceof to work with primitives">
    `instanceof` checks the prototype chain, which primitives don't have:
    
    ```javascript
    // ❌ Always false for primitives
    'hello' instanceof String  // false
    42 instanceof Number       // false
    
    // ✓ Use typeof for primitives
    typeof 'hello' === 'string'  // true
    typeof 42 === 'number'       // true
    ```
  </Accordion>
  
  <Accordion title="Not handling both null and undefined">
    When checking for missing values, remember there are two:
    
    ```javascript
    // ❌ Incomplete — misses undefined
    if (value === null) {
      return 'No value'
    }
    
    // ✓ Complete — handles both
    if (value == null) {  // Loose equality catches both
      return 'No value'
    }
    
    // ✓ Also complete
    if (value === null || value === undefined) {
      return 'No value'
    }
    ```
  </Accordion>
  
  <Accordion title="Forgetting Symbol properties are hidden">
    Symbol-keyed properties don't show up in normal iteration:
    
    ```javascript
    const secret = Symbol('secret')
    const obj = {
      visible: 'hello',
      [secret]: 'hidden'
    }
    
    // ❌ Symbol properties are invisible here
    Object.keys(obj)       // ['visible']
    JSON.stringify(obj)    // '{"visible":"hello"}'
    for (const key in obj) // Only 'visible'
    
    // ✓ Use these to access Symbol properties
    Object.getOwnPropertySymbols(obj)  // [Symbol(secret)]
    Reflect.ownKeys(obj)               // ['visible', Symbol(secret)]
    ```
  </Accordion>
</AccordionGroup>

---

## Key Takeaways

<Info>
**The key things to remember about JavaScript type nuances:**

1. **undefined means uninitialized, null means intentionally empty** — JavaScript returns `undefined` automatically; use `null` to explicitly indicate "no value"

2. **typeof null === 'object' is a bug** — It's a historical quirk that can't be fixed. Use `value === null` for null checks

3. **Use ?? instead of || for defaults** — Nullish coalescing (`??`) only triggers on `null`/`undefined`, preserving valid values like `0` and `''`

4. **Optional chaining (?.) prevents TypeError** — It short-circuits to `undefined` instead of throwing when accessing properties on null/undefined

5. **Symbols are guaranteed unique** — Every `Symbol()` call creates a new unique value, solving property name collision problems

6. **Well-known symbols customize object behavior** — `Symbol.iterator`, `Symbol.hasInstance`, and others let you hook into JavaScript's built-in operations

7. **instanceof checks the prototype chain** — It tests if a constructor's prototype exists in an object's chain, not the object's type

8. **BigInt handles integers beyond 2^53** — Use the `n` suffix or `BigInt()` for numbers larger than `Number.MAX_SAFE_INTEGER`

9. **BigInt and Number don't mix** — Convert explicitly with `BigInt()` or `Number()` before combining them

10. **Use == null to check for both null and undefined** — This is the one case where loose equality is preferred
</Info>

---

## Test Your Knowledge

<AccordionGroup>
  <Accordion title="Question 1: What's the difference between null and undefined?">
    **Answer:**
    
    `undefined` means a variable exists but hasn't been assigned a value. JavaScript uses it automatically for uninitialized variables, missing object properties, and functions without return statements.
    
    `null` is an explicit assignment meaning "intentionally empty" or "no value." Developers use it to indicate that a variable should have no value.
    
    ```javascript
    let x          // undefined (uninitialized)
    let y = null   // null (intentionally empty)
    
    typeof x       // 'undefined'
    typeof y       // 'object' (bug!)
    
    x == y         // true (loose equality)
    x === y        // false (strict equality)
    ```
  </Accordion>
  
  <Accordion title="Question 2: What's the output of these expressions?">
    ```javascript
    0 || 'fallback'
    0 ?? 'fallback'
    '' || 'fallback'
    '' ?? 'fallback'
    ```
    
    **Answer:**
    
    ```javascript
    0 || 'fallback'   // 'fallback' — 0 is falsy
    0 ?? 'fallback'   // 0 — 0 is not nullish
    '' || 'fallback'  // 'fallback' — '' is falsy
    '' ?? 'fallback'  // '' — '' is not nullish
    ```
    
    `||` triggers on any falsy value (`false`, `0`, `''`, `null`, `undefined`, `NaN`).
    `??` only triggers on `null` or `undefined`.
  </Accordion>
  
  <Accordion title="Question 3: Why does typeof null return 'object'?">
    **Answer:**
    
    It's a bug from the first version of JavaScript in 1995. In the original implementation, values were stored with a type tag. Objects had type tag `0`. `null` was represented as the NULL pointer (`0x00`), which also had type tag `0`. So `typeof null` returned `'object'`.
    
    This bug can never be fixed because it would break too much existing code. To check for `null`, use `value === null` instead.
  </Accordion>
  
  <Accordion title="Question 4: How would you check if a value is null OR undefined in one condition?">
    **Answer:**
    
    Use loose equality with `null`:
    
    ```javascript
    // This catches both null and undefined
    if (value == null) {
      console.log('No value')
    }
    
    // This is equivalent but more verbose
    if (value === null || value === undefined) {
      console.log('No value')
    }
    ```
    
    Loose equality (`==`) treats `null` and `undefined` as equal to each other (and nothing else), making it perfect for this use case.
  </Accordion>
  
  <Accordion title="Question 5: What's the difference between Symbol('id') and Symbol.for('id')?">
    **Answer:**
    
    `Symbol('id')` creates a new unique symbol every time. Two calls with the same description still produce different symbols:
    
    ```javascript
    Symbol('id') === Symbol('id')  // false
    ```
    
    `Symbol.for('id')` creates a symbol in the global registry. Subsequent calls with the same key return the same symbol:
    
    ```javascript
    Symbol.for('id') === Symbol.for('id')  // true
    ```
    
    Use `Symbol()` for private, local symbols. Use `Symbol.for()` when you need to share a symbol across different parts of your code or even different iframes.
  </Accordion>
  
  <Accordion title="Question 6: Why can't you do 10n + 5 in JavaScript?">
    **Answer:**
    
    JavaScript doesn't allow mixing BigInt and Number in arithmetic operations. This is a deliberate design choice to prevent accidental precision loss:
    
    ```javascript
    10n + 5  // TypeError: Cannot mix BigInt and other types
    ```
    
    To fix it, convert to the same type first:
    
    ```javascript
    10n + BigInt(5)  // 15n
    Number(10n) + 5  // 15
    ```
    
    Be careful with `Number()` conversion. For very large BigInt values, you'll lose precision because Number can only safely represent integers up to 2^53 - 1.
  </Accordion>
</AccordionGroup>

---

## Related Concepts

<CardGroup cols={2}>
  <Card title="Primitive Types" icon="cube" href="/concepts/primitive-types">
    The foundation for understanding JavaScript's seven primitive types
  </Card>
  <Card title="Type Coercion" icon="shuffle" href="/concepts/type-coercion">
    How JavaScript converts between types automatically
  </Card>
  <Card title="Equality Operators" icon="equals" href="/concepts/equality-operators">
    The difference between == and === and when to use each
  </Card>
  <Card title="Temporal Dead Zone" icon="clock" href="/beyond/concepts/temporal-dead-zone">
    Why typeof throws for let/const before declaration
  </Card>
</CardGroup>

---

## Reference

<CardGroup cols={2}>
  <Card title="null — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null">
    Official documentation for the null primitive value
  </Card>
  <Card title="undefined — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">
    Reference for the undefined global property
  </Card>
  <Card title="typeof — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">
    Complete reference for the typeof operator and its return values
  </Card>
  <Card title="Nullish Coalescing (??) — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing">
    Documentation for the nullish coalescing operator
  </Card>
  <Card title="Optional Chaining (?.) — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">
    Reference for safe property access with optional chaining
  </Card>
  <Card title="Symbol — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">
    Complete guide to the Symbol primitive and well-known symbols
  </Card>
  <Card title="BigInt — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">
    Documentation for arbitrary-precision integers in JavaScript
  </Card>
  <Card title="instanceof — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">
    Reference for the instanceof operator and prototype chain checking
  </Card>
</CardGroup>

---

## Articles

<CardGroup cols={2}>
  <Card title="JavaScript Data Types — javascript.info" icon="newspaper" href="https://javascript.info/types">
    Comprehensive coverage of all JavaScript types including null, undefined, and Symbol. Includes interactive exercises to test understanding.
  </Card>
  <Card title="The History of typeof null — Dr. Axel Rauschmayer" icon="newspaper" href="https://2ality.com/2013/10/typeof-null.html">
    Deep dive into why typeof null returns 'object'. Explains the original JavaScript implementation and why this bug can never be fixed.
  </Card>
  <Card title="ES2020 Nullish Coalescing and Optional Chaining — V8 Blog" icon="newspaper" href="https://v8.dev/features/nullish-coalescing">
    Official V8 blog explaining the rationale behind ?? and ?. operators. Includes performance considerations and edge cases.
  </Card>
  <Card title="JavaScript Symbols — CSS-Tricks" icon="newspaper" href="https://css-tricks.com/understanding-javascript-symbols/">
    Practical introduction to Symbols with real-world use cases. Great for understanding when and why you'd actually use Symbols in production.
  </Card>
  <Card title="BigInt: Arbitrary Precision Integers — javascript.info" icon="newspaper" href="https://javascript.info/bigint">
    Clear tutorial on BigInt covering creation, operations, and common pitfalls. Includes comparison with regular numbers and conversion gotchas.
  </Card>
</CardGroup>

---

## Videos

<CardGroup cols={2}>
  <Card title="JavaScript Symbols in 100 Seconds — Fireship" icon="video" href="https://www.youtube.com/watch?v=XTHuXLJlJSQ">
    Quick, entertaining overview of what Symbols are and why they exist. Perfect starting point before diving deeper.
  </Card>
  <Card title="null vs undefined — Web Dev Simplified" icon="video" href="https://www.youtube.com/watch?v=qTGbWfEfJBw">
    Beginner-friendly explanation of the differences between null and undefined. Covers when JavaScript uses each and best practices.
  </Card>
  <Card title="Optional Chaining and Nullish Coalescing — Fireship" icon="video" href="https://www.youtube.com/watch?v=v2tJ3nzXh8I">
    Fast-paced tutorial on ?. and ?? operators. Shows practical patterns and how they solve real problems in modern JavaScript.
  </Card>
  <Card title="JavaScript typeof Operator — Programming with Mosh" icon="video" href="https://www.youtube.com/watch?v=FSs_JYwnAdI">
    Clear walkthrough of typeof behavior including quirks and best practices. Good for understanding type checking in JavaScript.
  </Card>
</CardGroup>
