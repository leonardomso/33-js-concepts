---
title: "Value vs Reference Types: How Memory Works in JavaScript"
sidebarTitle: "Value vs Reference Types: How Memory Works"
description: "Learn how value types and reference types work in JavaScript. Understand how primitives and objects are stored, why copying objects shares references, and how to avoid mutation bugs."
---

Have you ever wondered why changing one variable unexpectedly changes another? Why does this happen?

```javascript
const original = { name: "Alice" };
const copy = original;
copy.name = "Bob";

console.log(original.name);  // "Bob" â€” Wait, what?!
```

The answer lies in how JavaScript stores data in memory. **Primitives** (like numbers and strings) store actual values, while **objects** store *references* (pointers) to data. This difference causes countless bugs in JavaScript code.

<Info>
**What you'll learn in this guide:**
- How JavaScript stores primitives vs objects in memory
- Why copying an object doesn't create a new object
- The difference between "pass by value" and "pass by reference"
- Why `{} === {}` returns `false`
- How to properly clone objects (shallow vs deep copy)
- Common bugs caused by reference sharing
</Info>

<Warning>
**Prerequisite:** This guide assumes you understand [Primitive Types](/concepts/primitive-types). If you're not familiar with the 7 primitive types in JavaScript, read that guide first!
</Warning>

---

## What Are Value Types and Reference Types?

JavaScript has two categories of data types that behave very differently:

### Value Types (Primitives)

**The 7 primitive types** store their values directly:

| Type | Example | Stored As |
|------|---------|-----------|
| `string` | `"hello"` | The string value |
| `number` | `42` | The numeric value |
| `bigint` | `9007199254740993n` | The large integer value |
| `boolean` | `true` | The boolean value |
| `undefined` | `undefined` | The undefined value |
| `null` | `null` | The null value |
| [`symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) | `Symbol("id")` | The unique symbol |

**Key characteristics:**
- Behave as if stored directly in the variable
- Immutable â€” you can't change them, only replace them
- Copied by value â€” copies are independent
- Compared by value â€” same value = equal

<Info>
**Under the hood:** Modern JavaScript engines optimize string storage through a technique called "string interning" â€” identical strings may share the same memory location internally. However, this is an optimization detail; strings still *behave* as independent values when you work with them.
</Info>

### Reference Types

**Everything else** is a reference type:

| Type | Example | Stored As |
|------|---------|-----------|
| Object | `{ name: "Alice" }` | Reference to object |
| Array | `[1, 2, 3]` | Reference to array |
| Function | `function() {}` | Reference to function |
| Date | `new Date()` | Reference to date |
| RegExp | `/pattern/` | Reference to regex |
| [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) | `new Map()` | Reference to map |
| [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) | `new Set()` | Reference to set |

**Key characteristics:**
- Variable stores a *reference* (pointer) to the actual data
- Mutable â€” you CAN change their contents
- Copied by reference â€” copies point to the SAME object
- Compared by reference â€” same reference = equal (not same contents!)

---

## The Sticky Note vs The Map: A Real-World Analogy

Imagine you have two ways to share information with a friend:

**Sticky Note (Value Types):** You write "42" on a sticky note and hand it to your friend. They now have their own note with "42" on it. If they change their note to "100", your note still says "42". You each have independent copies.

**Map to Treasure (Reference Types):** Instead of giving your friend the treasure itself, you give them a map to where the treasure is buried. Now you BOTH have maps pointing to the SAME treasure. If they dig it up and add more gold, you'll see the extra gold too, because you're both looking at the same treasure!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VALUE TYPES vs REFERENCE TYPES                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  VALUE TYPE (Sticky Note)              REFERENCE TYPE (Map to Treasure)  â”‚
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚   x = 42    â”‚                       â”‚  x = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚          â”‚
â”‚                                                               â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   y = 42    â”‚  (independent copy)   â”‚  y = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ {...}   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Change y?                             Change the object via y?          â”‚
â”‚  x stays the same!                     x sees the change too!            â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This difference between "storing the value itself" vs "storing a map to the value" is fundamental to understanding JavaScript.

<Tip>
**Quick Rule:** Primitives store the actual value. Copying creates an independent copy. Objects and arrays store a *reference* (pointer). Copying creates another pointer to the SAME data.
</Tip>

---

## How Memory Works: Stack vs Heap

To truly understand the difference, you need to know where JavaScript stores data.

<Info>
**Important note:** The stack/heap model described below is a **conceptual simplification** to help you understand how value types and reference types *behave*. The JavaScript specification doesn't define where values are stored in memoryâ€”actual engines (V8, SpiderMonkey, etc.) may optimize storage differently. What matters is understanding the *behavior* difference, not the physical memory location.
</Info>

### The Stack: Home of Primitives

The **stack** is a fast, organized region of memory. It stores:
- Primitive values
- References (pointers) to objects
- Function call information

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              THE STACK                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚  â”‚  name     =  "Alice"       â”‚  â† Actual string value                   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                          â”‚
â”‚  â”‚  age      =  25            â”‚  â† Actual number value                   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                          â”‚
â”‚  â”‚  isActive =  true          â”‚  â† Actual boolean value                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                          â”‚
â”‚  â”‚  user     =  0x7F3A  â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ Points to heap                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                                          â”‚
â”‚                        Fixed size, fast access                           â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The Heap: Home of Objects

The **heap** is a larger, less organized region for dynamic data:
- Objects
- Arrays
- Functions
- Anything that can grow or change size

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                               THE HEAP                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚    â”‚  0x7F3A:                            â”‚                               â”‚
â”‚    â”‚  {                                  â”‚                               â”‚
â”‚    â”‚    name: "Alice",                   â”‚                               â”‚
â”‚    â”‚    age: 25,                         â”‚                               â”‚
â”‚    â”‚    hobbies: ["reading", "gaming"]   â”‚                               â”‚
â”‚    â”‚  }                                  â”‚                               â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚    â”‚  0x8B2C:                            â”‚                               â”‚
â”‚    â”‚  [1, 2, 3, 4, 5]                    â”‚                               â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                          â”‚
â”‚                       Dynamic size, slower access                        â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Putting It All Together

When you create variables, here's what happens:

```javascript
let name = "Alice";           // String stored on stack
let age = 25;                 // Number stored on stack
let user = { name: "Alice" }; // Reference on stack, object on heap
let scores = [95, 87, 92];    // Reference on stack, array on heap
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         STACK AND HEAP TOGETHER                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  STACK                              HEAP                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ name   = "Alice"    â”‚           â”‚                            â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚
â”‚  â”‚ age    = 25         â”‚           â”‚  â”‚ { name: "Alice" }    â”‚  â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚
â”‚  â”‚ user   = 0x001 â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²                 â”‚        â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚                            â”‚        â”‚
â”‚  â”‚ scores = 0x002 â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â””â”€â–ºâ”‚ [95, 87, 92]     â”‚  â”‚        â”‚
â”‚                                    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Copying Behavior: The Critical Difference

This is where things get interesting, and where bugs love to hide.

### Copying Primitives: Independent Copies

When you copy a primitive, you get a completely independent value:

```javascript
let a = 10;
let b = a;      // b gets a COPY of the value 10

b = 20;         // changing b has NO effect on a

console.log(a); // 10 (unchanged!)
console.log(b); // 20
```

**What happens in memory:**

```
STEP 1: let a = 10         STEP 2: let b = a         STEP 3: b = 20

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  a  =  10    â”‚           â”‚  a  =  10    â”‚           â”‚  a  =  10    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                           â”‚  b  =  10    â”‚ (copy!)   â”‚  b  =  20    â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                           Two independent             Changing b
                           copies of 10                doesn't touch a
```

### Copying Objects: Shared References

When you copy an object, you copy the *reference*. Both variables now point to the SAME object:

```javascript
let obj1 = { name: "Alice" };
let obj2 = obj1;       // obj2 gets a COPY of the REFERENCE

obj2.name = "Bob";     // modifies the SAME object!

console.log(obj1.name); // "Bob" (changed!)
console.log(obj2.name); // "Bob"
```

**What happens in memory:**

```
STEP 1: Create obj1                    STEP 2: let obj2 = obj1

STACK          HEAP                    STACK          HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚obj1 = 0x01â”€â”¼â”€â–ºâ”‚ { name: "Alice" }â”‚    â”‚obj1 = 0x01â”€â”¼â”€â”€â–ºâ”‚ { name: "Alice" }â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚                  â”‚
                                       â”‚obj2 = 0x01â”€â”¼â”€â”€â–º  (same object!)  â”‚
                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 3: obj2.name = "Bob"

STACK          HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚obj1 = 0x01â”€â”¼â”€â”€â–ºâ”‚ { name: "Bob" } â”‚  â† Both see this change!
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚                  â”‚
â”‚obj2 = 0x01â”€â”¼â”€â”€â–º  (same object!)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The Array Surprise

Arrays are objects too, so they behave the same way:

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1;        // arr2 points to the SAME array

arr2.push(4);           // modifies the shared array

console.log(arr1);      // [1, 2, 3, 4] â€” Wait, what?!
console.log(arr2);      // [1, 2, 3, 4]
```

<Warning>
**This catches EVERYONE at first!** When you write `let arr2 = arr1`, you're NOT creating a new array. You're creating a second variable that points to the same array. Any changes through either variable affect both.
</Warning>

---

## Comparison Behavior

### Primitives: Compared by Value

Two primitives are equal if they have the same value:

```javascript
let a = "hello";
let b = "hello";
console.log(a === b);   // true â€” same value

let x = 42;
let y = 42;
console.log(x === y);   // true â€” same value
```

### Objects: Compared by Reference

Two objects are equal only if they are the SAME object (same reference):

```javascript
let obj1 = { name: "Alice" };
let obj2 = { name: "Alice" };
console.log(obj1 === obj2);  // false â€” different objects!

let obj3 = obj1;
console.log(obj1 === obj3);  // true â€” same reference
```

**Visual explanation:**

```
obj1 and obj2: Different objects, same contents

STACK          HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚obj1 = 0x01â”€â”¼â”€â–ºâ”‚ { name: "Alice" }â”‚  â† Object A
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚obj2 = 0x02â”€â”¼â”€â–ºâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ { name: "Alice" }â”‚  â† Object B (different!)
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

obj1 === obj2?  0x01 === 0x02?  FALSE!
```

```
obj1 and obj3: Same object

STACK          HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚obj1 = 0x01â”€â”¼â”€â”€â–ºâ”‚ { name: "Alice" }â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚                  â”‚
â”‚obj3 = 0x01â”€â”¼â”€â”€â–º  (same object!)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

obj1 === obj3?  0x01 === 0x01?  TRUE!
```

### The Empty Object/Array Trap

```javascript
console.log({} === {});     // false â€” two different empty objects
console.log([] === []);     // false â€” two different empty arrays
console.log([1,2] === [1,2]); // false â€” two different arrays
```

<Tip>
**How to compare objects/arrays by content:**

```javascript
// Simple (but limited) approach
JSON.stringify(obj1) === JSON.stringify(obj2)

// For arrays of primitives
arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i])

// For complex cases, use a library like Lodash
_.isEqual(obj1, obj2)
```

**Caution with JSON.stringify:** Property order matters! `{a:1, b:2}` and `{b:2, a:1}` will produce different strings even though they're logically equal. It also fails with `undefined`, functions, Symbols, circular references, `NaN`, and `Infinity`. For reliable deep equality, use a library like Lodash's `_.isEqual()`.
</Tip>

---

## Functions and Parameters

Here's a topic that confuses even experienced developers:

**JavaScript is ALWAYS "pass by value"**, but when passing objects, the *value being passed is a reference*.

### Passing Primitives

When you pass a primitive to a function, the function receives a copy:

```javascript
function double(num) {
  num = num * 2;    // changes the LOCAL copy only
  return num;
}

let x = 10;
let result = double(x);

console.log(x);       // 10 (unchanged!)
console.log(result);  // 20
```

**What happens:**

```
BEFORE double(x):     INSIDE double(x):      AFTER double(x):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  x  =  10    â”‚      â”‚  x  =  10    â”‚       â”‚  x  =  10    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ num =  10    â”‚ (copy)
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ num =  20    â”‚ (modified copy)
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Passing Objects: Mutation WORKS

When you pass an object, the function receives a copy of the reference. Both point to the same object:

```javascript
function rename(person) {
  person.name = "Bob";  // mutates the ORIGINAL object!
}

let user = { name: "Alice" };
rename(user);

console.log(user.name);  // "Bob" â€” changed!
```

**What happens:**

```
BEFORE rename(user):        INSIDE rename(user):

STACK          HEAP         STACK          HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚user = 0x01â”€â”¼â”€â–º{ name:     â”‚user = 0x01â”€â”¼â”€â”€â–º{ name: "Bob" }
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  "Alice" }   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â–²
                            â”‚person=0x01â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”˜
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  (same object!)
```

### Passing Objects: Reassignment DOESN'T Work

But if you reassign the parameter, you're only changing the local copy of the reference:

```javascript
function replace(person) {
  person = { name: "Charlie" };  // creates NEW local object
}

let user = { name: "Alice" };
replace(user);

console.log(user.name);  // "Alice" â€” unchanged!
```

**What happens:**

```
INSIDE replace(user):

STACK          HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚user = 0x01â”€â”¼â”€â–ºâ”‚ { name: "Alice" }â”‚  â† Original, unchanged
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚person=0x02â”€â”¼â”€â–ºâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ { name: "Charlie" }â”‚  â† New object, discarded
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<Info>
**The key insight:** You can *mutate* an object through a function parameter, but you cannot *replace* the original object. Reassigning the parameter only changes where that local variable points.
</Info>

---

## Mutation vs Reassignment

Understanding this distinction is crucial for avoiding bugs.

### Mutation: Changing the Contents

Mutation modifies the existing object in place:

```javascript
const arr = [1, 2, 3];

// These are all MUTATIONS:
arr.push(4);         // [1, 2, 3, 4]
arr[0] = 99;         // [99, 2, 3, 4]
arr.pop();           // [99, 2, 3]
arr.sort();          // modifies in place

const obj = { name: "Alice" };

// These are all MUTATIONS:
obj.name = "Bob";        // changes property
obj.age = 25;            // adds property
delete obj.age;          // removes property
```

### Reassignment: Pointing to a New Value

Reassignment makes the variable point to something else entirely:

```javascript
let arr = [1, 2, 3];
arr = [4, 5, 6];      // REASSIGNMENT â€” new array

let obj = { name: "Alice" };
obj = { name: "Bob" }; // REASSIGNMENT â€” new object
```

### The `const` Trap

`const` prevents **reassignment** but NOT **mutation**:

```javascript
const arr = [1, 2, 3];

// âœ… Mutations are ALLOWED:
arr.push(4);           // works!
arr[0] = 99;           // works!

// âŒ Reassignment is BLOCKED:
arr = [4, 5, 6];       // TypeError: Assignment to constant variable

const obj = { name: "Alice" };

// âœ… Mutations are ALLOWED:
obj.name = "Bob";      // works!
obj.age = 25;          // works!

// âŒ Reassignment is BLOCKED:
obj = { name: "Eve" }; // TypeError: Assignment to constant variable
```

<Warning>
**Common misconception:** Many developers think `const` creates an "immutable" variable. It doesn't! It only prevents reassignment. The contents of objects and arrays declared with `const` can still be changed.
</Warning>

---

## True Immutability with [`Object.freeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)

We learned that `const` doesn't make objects immutable. It only prevents reassignment. But what if you NEED a truly immutable object?

### Object.freeze(): Shallow Immutability

`Object.freeze()` prevents any changes to an object's properties:

```javascript
const user = Object.freeze({ name: "Alice", age: 25 });

user.name = "Bob";      // Silently fails (or throws in strict mode)
user.email = "a@b.com"; // Can't add properties
delete user.age;        // Can't delete properties

console.log(user);      // { name: "Alice", age: 25 } â€” unchanged!
```

**What Object.freeze() prevents:**
- Changing existing property values
- Adding new properties
- Deleting properties
- Changing property descriptors (like making a property writable)

### Checking If an Object Is Frozen

```javascript
const frozen = Object.freeze({ a: 1 });
const normal = { a: 1 };

console.log(Object.isFrozen(frozen)); // true
console.log(Object.isFrozen(normal)); // false
```

<Warning>
**Object.freeze() is shallow!** It only freezes the top level. Nested objects can still be modified:

```javascript
const user = Object.freeze({
  name: "Alice",
  address: { city: "NYC" }
});

user.name = "Bob";           // Blocked
user.address.city = "LA";    // Works! Nested object not frozen

console.log(user.address.city); // "LA"
```
</Warning>

### Deep Freeze: Making Everything Immutable

To freeze nested objects too, you need a recursive "deep freeze" function:

```javascript
function deepFreeze(obj, seen = new WeakSet()) {
  // Prevent infinite loops from circular references
  if (seen.has(obj)) return obj;
  seen.add(obj);
  
  // Get all property names (including symbols)
  const propNames = Reflect.ownKeys(obj);
  
  // Freeze nested objects first
  for (const name of propNames) {
    const value = obj[name];
    if (value && typeof value === "object") {
      deepFreeze(value, seen);
    }
  }
  
  // Then freeze the object itself
  return Object.freeze(obj);
}

const user = deepFreeze({
  name: "Alice",
  address: { city: "NYC" }
});

user.address.city = "LA";       // Now this is blocked too!
console.log(user.address.city); // "NYC"
```

<Info>
**Why the `seen` WeakSet?** Objects can have circular references (e.g., `obj.self = obj`). Without tracking visited objects, the function would recurse infinitely. The WeakSet ensures each object is only processed once.
</Info>

### Related Methods: freeze vs seal vs preventExtensions

| Method | Add Properties | Delete Properties | Change Values |
|--------|:-------------:|:-----------------:|:-------------:|
| `Object.freeze()` | No | No | No |
| `Object.seal()` | No | No | **Yes** |
| `Object.preventExtensions()` | No | **Yes** | **Yes** |

```javascript
// Object.seal() â€” can change values, but can't add/delete
const sealed = Object.seal({ name: "Alice" });
sealed.name = "Bob";    // Works!
sealed.age = 25;        // Fails â€” can't add
delete sealed.name;     // Fails â€” can't delete

// Object.preventExtensions() â€” can change/delete, but can't add
const noExtend = Object.preventExtensions({ name: "Alice" });
noExtend.name = "Bob";  // Works!
delete noExtend.name;   // Works!
noExtend.age = 25;      // Fails â€” can't add
```

<Tip>
**When to use Object.freeze():**
- Configuration objects that should never change
- Constants or enums in your application
- Protecting objects passed to untrusted code
- Debugging mutation bugs (freeze the object and see what breaks!)
</Tip>

---

## Shallow Copy vs Deep Copy

When you need a truly independent copy of an object, you have two options.

### Shallow Copy: One Level Deep

A shallow copy creates a new object with copies of the top-level properties. But nested objects are still shared!

**Shallow copy methods:**

```javascript
const original = { 
  name: "Alice",
  scores: [95, 87, 92],
  address: { city: "NYC" }
};

// Method 1: Spread operator
const copy1 = { ...original };

// Method 2: Object.assign
const copy2 = Object.assign({}, original);

// For arrays:
const arrCopy1 = [...originalArray];
const arrCopy2 = originalArray.slice();
const arrCopy3 = Array.from(originalArray);
```

**The problem with shallow copy:**

```javascript
const original = { 
  name: "Alice",
  address: { city: "NYC" }
};

const shallow = { ...original };

// Top-level changes are independent:
shallow.name = "Bob";
console.log(original.name);  // "Alice" âœ…

// But nested objects are SHARED:
shallow.address.city = "LA";
console.log(original.address.city);  // "LA" ğŸ˜±
```

**Visual explanation:**

```
SHALLOW COPY

original                     shallow
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ name: "Alice"   â”‚          â”‚ name: "Alice"   â”‚  (independent copy)
â”‚ address: 0x01 â”€â”€â”¼â”€â”€â”€â”€â”     â”‚ address: 0x01 â”€â”€â”¼â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                       â”‚                            â”‚
                       â–¼                            â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ { city: "NYC" } â”‚  â† SHARED! Both point here
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Deep Copy: All Levels

A deep copy creates completely independent copies at every level.

**Method 1: [`structuredClone()`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) (Recommended)**

```javascript
const original = { 
  name: "Alice",
  scores: [95, 87, 92],
  address: { city: "NYC" },
  date: new Date()
};

const deep = structuredClone(original);

// Now everything is independent:
deep.address.city = "LA";
console.log(original.address.city);  // "NYC" âœ…

deep.scores.push(100);
console.log(original.scores);  // [95, 87, 92] âœ…
```

**Method 2: JSON trick (has limitations)**

```javascript
const deep = JSON.parse(JSON.stringify(original));
```

### Comparing the Methods

<Tabs>
  <Tab title="structuredClone()">
    **Pros:**
    - Handles most types correctly
    - Preserves Dates, Maps, Sets, ArrayBuffers
    - Handles circular references
    - Built into JavaScript (ES2022+)
    
    **Cons:**
    - Cannot clone functions
    - Cannot clone DOM nodes
    - Cannot clone property descriptors, getters/setters
    - Cannot clone the prototype chain
    - Symbol-keyed properties are ignored
    - Error objects lose their stack trace (only `message` is preserved)
    - Not available in older browsers (pre-2022)
    
    ```javascript
    const obj = {
      date: new Date(),
      set: new Set([1, 2, 3]),
      map: new Map([["key", "value"]])
    };
    
    const clone = structuredClone(obj);
    // Works perfectly! âœ…
    ```
  </Tab>
  <Tab title="JSON.parse/stringify">
    **Pros:**
    - Works in all browsers
    - Simple to use
    
    **Cons:**
    - **Loses functions** â€” they disappear
    - **Loses undefined** â€” properties with undefined are removed
    - **Converts Dates to strings** â€” not Date objects
    - **Cannot handle circular references** â€” throws error
    - **Loses Symbol keys** â€” they're ignored
    - **Loses Map/Set** â€” converted to empty objects
    
    ```javascript
    const obj = {
      fn: () => {},           // âŒ lost
      date: new Date(),       // âŒ becomes string
      undef: undefined,       // âŒ property removed
      set: new Set([1, 2])    // âŒ becomes {}
    };
    
    const clone = JSON.parse(JSON.stringify(obj));
    // { date: "2025-12-29T..." }  â€” Most data lost!
    ```
  </Tab>
</Tabs>

<Tip>
**Which to use:**
- **`structuredClone()`** â€” Use this for most cases (modern browsers)
- **JSON trick** â€” Only for simple objects with no functions, dates, or special types
- **Lodash `_.cloneDeep()`** â€” When you need maximum compatibility
</Tip>

---

## Common Bugs and Pitfalls

<AccordionGroup>
  <Accordion title="1. Accidental Object/Array Mutation">
    ```javascript
    // BUG: Modifying function parameter
    function processUsers(users) {
      users.push({ name: "New User" });  // Mutates original!
      return users;
    }
    
    const myUsers = [{ name: "Alice" }];
    processUsers(myUsers);
    console.log(myUsers);  // [{ name: "Alice" }, { name: "New User" }]
    
    // FIX: Create a copy first
    function processUsers(users) {
      const copy = [...users];
      copy.push({ name: "New User" });
      return copy;
    }
    ```
  </Accordion>
  
  <Accordion title="2. Array Methods That Mutate">
    ```javascript
    // These MUTATE the original array:
    arr.push()      arr.pop()
    arr.shift()     arr.unshift()
    arr.splice()    arr.sort()
    arr.reverse()   arr.fill()
    
    // These RETURN a new array (safe):
    arr.map()       arr.filter()
    arr.slice()     arr.concat()
    arr.flat()      arr.flatMap()
    arr.toSorted()  arr.toReversed()  // ES2023
    arr.toSpliced() // ES2023
    
    // GOTCHA: sort() mutates!
    const nums = [3, 1, 2];
    const sorted = nums.sort();  // nums is NOW [1, 2, 3]!
    
    // FIX: Copy first, or use toSorted()
    const sorted = [...nums].sort();
    const sorted = nums.toSorted();  // ES2023
    ```
  </Accordion>
  
  <Accordion title="3. Comparing Objects/Arrays">
    ```javascript
    // BUG: This will NEVER work
    if (user1 === user2) { }      // Compares references
    if (arr1 === arr2) { }        // Compares references
    if (config === defaultConfig) { }  // Compares references
    
    // Even these fail:
    [] === []                      // false
    {} === {}                      // false
    [1, 2] === [1, 2]              // false
    
    // FIX: Compare contents
    JSON.stringify(a) === JSON.stringify(b)  // Simple but limited
    
    // Or use a deep equality function
    function deepEqual(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    }
    ```
  </Accordion>
  
  <Accordion title="4. Shallow Copy with Nested Objects">
    ```javascript
    // BUG: Shallow copy doesn't clone nested objects
    const user = {
      name: "Alice",
      settings: { theme: "dark" }
    };
    
    const copy = { ...user };
    copy.settings.theme = "light";
    
    console.log(user.settings.theme);  // "light" â€” Original changed!
    
    // FIX: Use deep copy
    const copy = structuredClone(user);
    ```
  </Accordion>
  
  <Accordion title="5. Shared Default Object Reference">
    ```javascript
    // BUG: Default object gets mutated across calls
    function addItem(item, list = []) {
      list.push(item);
      return list;
    }
    
    // This works fine with primitives, but with objects...
    // Actually, this specific case is fine because default
    // parameters are evaluated fresh each call.
    
    // But THIS is a problem:
    const defaultList = [];
    function addItem(item, list = defaultList) {
      list.push(item);
      return list;
    }
    
    addItem("a");  // ["a"]
    addItem("b");  // ["a", "b"] â€” defaultList was mutated!
    ```
  </Accordion>
  
  <Accordion title="6. Forgetting Arrays Are Reference Types">
    ```javascript
    // BUG: Thinking you have two arrays
    const original = [1, 2, 3];
    const backup = original;  // NOT a backup!
    
    original.push(4);
    console.log(backup);  // [1, 2, 3, 4] â€” "backup" changed!
    
    // FIX: Actually copy the array
    const backup = [...original];
    const backup = original.slice();
    ```
  </Accordion>
  
  <Accordion title="7. Memory Leaks from Forgotten References (Advanced)">
    When you store objects in Maps or arrays, those references prevent garbage collection, even if you don't need the object anymore.
    
    ```javascript
    // Potential memory leak: cache holds references forever
    const cache = new Map();
    
    function processUser(user) {
      cache.set(user.id, user);  // user can never be garbage collected
    }
    
    // Even if user objects are no longer needed elsewhere,
    // the cache keeps them alive in memory
    ```
    
    **Solutions:**
    
    - **[WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)** â€” Keys are "weakly held" and can be garbage collected
    - **Manual cleanup** â€” Delete entries when done
    
    ```javascript
    // WeakMap: objects can be garbage collected when no other references exist
    const cache = new WeakMap();
    
    function processUser(user) {
      cache.set(user, computeExpensiveData(user));
    }
    // When 'user' object is no longer referenced elsewhere, 
    // it AND its cached data can be garbage collected
    ```
    
    <Info>
    **WeakMap vs Map:** WeakMap keys must be objects (not primitives), and you can't iterate over a WeakMap. Use it when you want cached data to automatically disappear when the source object is gone.
    </Info>
  </Accordion>
</AccordionGroup>

---

## Best Practices

<Tip>
**Guidelines for working with reference types:**

1. **Treat objects as immutable when possible**
   ```javascript
   // Instead of mutating:
   user.name = "Bob";
   
   // Create a new object:
   const updatedUser = { ...user, name: "Bob" };
   ```

2. **Use `const` by default** â€” prevents accidental reassignment

3. **Know which methods mutate**
   - Mutating: `push`, `pop`, `sort`, `reverse`, `splice`
   - Non-mutating: `map`, `filter`, `slice`, `concat`, `toSorted`

4. **Use `structuredClone()` for deep copies**
   ```javascript
   const clone = structuredClone(original);
   ```

5. **Be explicit about intent** â€” comment when mutating on purpose
   ```javascript
   // Intentionally mutating for performance
   largeArray.sort((a, b) => a - b);
   ```

6. **Clone function parameters if you need to modify them**
   ```javascript
   function processData(data) {
     const copy = structuredClone(data);
     // Now safe to modify copy
   }
   ```
</Tip>

---

## Key Takeaways

<Info>
**The key things to remember:**

1. **Value types** (primitives) store values directly; **reference types** store pointers

2. **Copying a primitive** creates an independent copy â€” changing one doesn't affect the other

3. **Copying an object/array** copies the reference â€” both point to the SAME data

4. **Comparison:** primitives compare by value, objects compare by reference

5. **Functions:** JavaScript passes everything by value, but object values ARE references

6. **Mutation â‰  Reassignment:** `const` only prevents reassignment, not mutation

7. **Shallow copy** (spread, Object.assign) only copies one level â€” nested objects are shared

8. **Deep copy** with `structuredClone()` creates completely independent copies

9. **Know your array methods:** `push/pop/sort` mutate; `map/filter/slice` don't

10. **True immutability** requires `Object.freeze()` â€” but it's shallow, so use deep freeze for nested objects
</Info>

---

## Test Your Knowledge

<AccordionGroup>
  <Accordion title="Question 1: What's the difference between value types and reference types?">
    **Answer:**
    
    - **Value types (primitives)** store the actual value directly. Copying creates an independent copy, and comparison checks if values are the same.
    
    - **Reference types (objects, arrays, functions)** store a pointer/reference to the data. Copying creates another pointer to the SAME data, and comparison checks if both point to the same object.
  </Accordion>
  
  <Accordion title="Question 2: What does this code output?">
    ```javascript
    let a = { count: 1 };
    let b = a;
    b.count = 5;
    console.log(a.count);
    ```
    
    **Answer:** `5`
    
    Both `a` and `b` point to the same object. When you modify `b.count`, you're modifying the shared object, which `a` also sees.
  </Accordion>
  
  <Accordion title="Question 3: Why does {} === {} return false?">
    **Answer:** Because `===` compares references, not contents.
    
    Each `{}` creates a NEW empty object in memory with a different reference. Even though they have the same contents (both empty), they are different objects at different memory addresses.
    
    ```javascript
    {} === {}  // false (different objects)
    
    const a = {};
    const b = a;
    a === b    // true (same reference)
    ```
  </Accordion>
  
  <Accordion title="Question 4: What's the difference between shallow and deep copy?">
    **Answer:**
    
    - **Shallow copy** creates a new object and copies top-level properties. Nested objects are NOT copied â€” they're still shared references.
    
    - **Deep copy** creates a completely independent copy at ALL levels. Nested objects are also cloned.
    
    ```javascript
    const original = { nested: { value: 1 } };
    
    // Shallow: nested is shared
    const shallow = { ...original };
    shallow.nested.value = 2;
    console.log(original.nested.value); // 2 (affected!)
    
    // Deep: completely independent
    const deep = structuredClone(original);
    deep.nested.value = 3;
    console.log(original.nested.value); // 2 (unchanged)
    ```
  </Accordion>
  
  <Accordion title="Question 5: Does const prevent object mutation?">
    **Answer:** No!
    
    `const` only prevents **reassignment** â€” you can't make the variable point to a different value. But you CAN still **mutate** the object's contents.
    
    ```javascript
    const obj = { name: "Alice" };
    
    obj.name = "Bob";  // âœ… Allowed (mutation)
    obj.age = 25;      // âœ… Allowed (mutation)
    obj = {};          // âŒ Error (reassignment)
    ```
  </Accordion>
  
  <Accordion title="Question 6: What happens when you pass an object to a function and modify it?">
    **Answer:** The original object IS modified!
    
    When you pass an object to a function, the function receives a copy of the reference. Both the original variable and the function parameter point to the same object. Mutations through either will affect the shared object.
    
    ```javascript
    function addAge(person) {
      person.age = 30;  // Mutates the original!
    }
    
    const user = { name: "Alice" };
    addAge(user);
    console.log(user.age);  // 30
    ```
    
    However, if you *reassign* the parameter inside the function, it only changes the local variable, not the original.
  </Accordion>
  
  <Accordion title="Question 7: Does Object.freeze() make nested objects immutable?">
    **Answer:** No! `Object.freeze()` is shallow.
    
    It only freezes the top-level properties. Nested objects can still be modified:
    
    ```javascript
    const user = Object.freeze({
      name: "Alice",
      address: { city: "NYC" }
    });
    
    user.name = "Bob";          // Blocked (frozen)
    user.address.city = "LA";   // Works! (nested object not frozen)
    
    console.log(user.address.city); // "LA"
    ```
    
    To freeze everything, you need a recursive "deep freeze" function that freezes all nested objects.
  </Accordion>
  
  <Accordion title="Question 8: What's the difference between Object.freeze() and const?">
    **Answer:** They protect different things:
    
    - **`const`** prevents **reassignment** â€” you can't make the variable point to a different value
    - **`Object.freeze()`** prevents **mutation** â€” you can't change the object's properties
    
    ```javascript
    // const alone: can mutate, can't reassign
    const obj1 = { a: 1 };
    obj1.a = 2;        // âœ… Works
    obj1 = {};         // âŒ Error
    
    // freeze alone: can reassign (if let), can't mutate
    let obj2 = Object.freeze({ a: 1 });
    obj2.a = 2;        // âŒ Fails silently
    obj2 = {};         // âœ… Works (it's let)
    
    // Both together: can't do either
    const obj3 = Object.freeze({ a: 1 });
    obj3.a = 2;        // âŒ Fails silently
    obj3 = {};         // âŒ Error
    ```
  </Accordion>
</AccordionGroup>

---

## Related Concepts

<CardGroup cols={2}>
  <Card title="Primitive Types" icon="atom" href="/concepts/primitive-types">
    Deep dive into the 7 primitive types and their characteristics
  </Card>
  <Card title="Type Coercion" icon="shuffle" href="/concepts/type-coercion">
    How JavaScript converts between types automatically
  </Card>
  <Card title="Scope and Closures" icon="layer-group" href="/concepts/scope-and-closures">
    How closures capture references to variables
  </Card>
  <Card title="Equality Operators" icon="equals" href="/concepts/equality-operators">
    Understanding == vs === and type checking
  </Card>
</CardGroup>

---

## Reference

<CardGroup cols={2}>
  <Card title="JavaScript Data Types â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">
    Official documentation on JavaScript's type system, including primitives and objects.
  </Card>
  <Card title="Object.freeze() â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">
    Documentation on freezing objects for immutability.
  </Card>
  <Card title="structuredClone() â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">
    The modern way to create deep copies of objects.
  </Card>
  <Card title="WeakMap â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">
    Maps with weak references that allow garbage collection.
  </Card>
</CardGroup>

## Articles

<CardGroup cols={2}>
  <Card title="Explaining Value vs. Reference in Javascript" icon="newspaper" href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0">
    Clear explanation by Arnav Aggarwal with visual diagrams showing how primitives and objects behave differently in memory.
  </Card>
  <Card title="JavaScript Primitive vs. Reference Values" icon="newspaper" href="https://www.javascripttutorial.net/javascript-primitive-vs-reference-values/">
    JavaScript Tutorial's guide includes animated diagrams showing stack vs heap memory allocation. Covers copying behavior and function parameter passing with runnable code examples.
  </Card>
  <Card title="Back to roots: JavaScript Value vs Reference" icon="newspaper" href="https://medium.com/dailyjs/back-to-roots-javascript-value-vs-reference-8fb69d587a18">
    Miro Koczka explains why `const` doesn't make objects immutable and how to avoid accidental mutations. Includes common bug patterns and fixes.
  </Card>
  <Card title="You Don't Know JS: Types & Grammar" icon="book" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/README.md">
    Kyle Simpson's definitive guide to JavaScript's type system. Free to read online.
  </Card>
</CardGroup>

## Videos

<CardGroup cols={2}>
  <Card title="JavaScript Value vs Reference Types â€” Programming with Mosh" icon="video" href="https://www.youtube.com/watch?v=fD0t_DKREbE">
    Mosh uses whiteboard diagrams to show exactly how primitives live on the stack while objects live on the heap. 10-minute video that makes memory concepts click.
  </Card>
  <Card title="Reference vs Primitive Values â€” Academind" icon="video" href="https://www.youtube.com/watch?v=9ooYYRLdg_g">
    Academind's Max demonstrates mutation bugs in real-time, then shows how to fix them with spread operators and structuredClone. Good for seeing the problems before learning solutions.
  </Card>
  <Card title="Javascript Pass by Value vs Pass by Reference â€” techsith" icon="video" href="https://www.youtube.com/watch?v=E-dAnFdq8k8">
    Focused explanation of how function parameters work with primitives vs objects. Great for understanding the "pass by value of the reference" concept.
  </Card>
</CardGroup>
