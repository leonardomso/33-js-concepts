---
title: "HTTP & Fetch"
description: "Making network requests in JavaScript"
---

How does JavaScript get data from a server? How do you load user profiles, submit forms, or fetch the latest posts from an API? The answer is the **[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)** — JavaScript's modern way to make network requests.

```javascript
// This is how you fetch data in JavaScript
const response = await fetch('https://api.example.com/users/1')
const user = await response.json()
console.log(user.name)  // "Alice"
```

But to really understand Fetch, you need to understand what's happening underneath: **[HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)**.

<Info>
**What you'll learn in this guide:**
- How HTTP requests and responses work
- The four main HTTP methods (GET, POST, PUT, DELETE)
- How to use the Fetch API to make requests
- Reading and parsing JSON responses
- The critical difference between network errors and HTTP errors
- Modern patterns with async/await
- How to cancel requests with AbortController
</Info>

## What is HTTP?

**[HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)** (Hypertext Transfer Protocol) is the protocol that powers the web. It's not a JavaScript thing — it's a set of rules that *all* web communication follows, regardless of programming language. When your browser loads a webpage, it uses HTTP. When your phone app talks to a server, it uses HTTP. When JavaScript fetches data, it uses HTTP.

<Warning>
**HTTP is not JavaScript.** HTTP is a language-agnostic protocol — Python, Ruby, Go, Java, and every other language uses it too. We cover HTTP basics in this guide because understanding the protocol is essential to using the Fetch API effectively. If you want to dive deeper into HTTP itself, check out the MDN resources below.
</Warning>

<CardGroup cols={2}>
  <Card title="HTTP — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/HTTP">
    Comprehensive guide to the HTTP protocol
  </Card>
  <Card title="An Overview of HTTP — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">
    Understanding the fundamentals of HTTP
  </Card>
</CardGroup>

---

## The Restaurant Analogy

HTTP follows a simple pattern called **request-response**. To understand it, imagine you're at a restaurant:

1. **You place an order** (the request) — "I'd like the pasta, please"
2. **The waiter takes it to the kitchen** (the network) — your order travels to where the food is prepared
3. **The kitchen prepares your meal** (the server) — they process your request and make your food
4. **The waiter brings back your food** (the response) — you receive what you asked for (hopefully!)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        THE REQUEST-RESPONSE CYCLE                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│    YOU (Browser)                              KITCHEN (Server)           │
│    ┌──────────┐                               ┌──────────────┐           │
│    │          │  ──── "I'd like pasta" ────►  │              │           │
│    │    :)    │         (REQUEST)             │    [chef]    │           │
│    │          │                               │              │           │
│    │          │  ◄──── Here you go! ────────  │              │           │
│    │          │         (RESPONSE)            │              │           │
│    └──────────┘                               └──────────────┘           │
│                                                                          │
│    The waiter (HTTP) is the protocol that makes this exchange work!      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

Sometimes things go wrong:
- **The kitchen is closed** (server is down) — You can't even place an order
- **They're out of pasta** (404 Not Found) — The order was received, but they can't fulfill it
- **Something's wrong in the kitchen** (500 Server Error) — They tried but something broke

This request-response cycle is the core of how the web works. The **Fetch API** is JavaScript's modern way to participate in this cycle programmatically.

<Warning>
**Prerequisite:** This guide assumes you understand [Promises](/concepts/promises) and [async/await](/concepts/async-await). Fetch is Promise-based, so those concepts are essential. If you're not comfortable with Promises yet, read that guide first!
</Warning>

---

## HTTP Fundamentals

Before diving into the Fetch API, let's understand the key concepts of HTTP itself.

### The Request-Response Model

Every HTTP interaction follows a simple pattern:

<Steps>
  <Step title="Client Sends Request">
    Your browser (the client) sends an HTTP request to a server. The request includes what you want (the URL), how you want it (the method), and any additional info (headers, body).
  </Step>
  
  <Step title="Server Processes Request">
    The server receives the request, does whatever work is needed (database queries, calculations, etc.), and prepares a response.
  </Step>
  
  <Step title="Server Sends Response">
    The server sends back an HTTP response containing a status code (success/failure), headers (metadata), and usually a body (the actual data).
  </Step>
  
  <Step title="Client Handles Response">
    Your JavaScript code receives the response and does something with it — display data, show an error, redirect the user, etc.
  </Step>
</Steps>

### HTTP Methods: What Do You Want to Do?

HTTP methods tell the server what action you want to perform. Think of them as verbs:

| Method | Purpose | Restaurant Analogy |
|--------|---------|-------------------|
| **GET** | Retrieve data | "Can I see the menu?" |
| **POST** | Create new data | "I'd like to place an order" |
| **PUT** | Update/replace data | "Actually, change my order to pizza" |
| **PATCH** | Partially update data | "Add extra cheese to my order" |
| **DELETE** | Remove data | "Cancel my order" |

```javascript
// GET - Retrieve a user
fetch('/api/users/123')

// POST - Create a new user
fetch('/api/users', {
  method: 'POST',
  body: JSON.stringify({ name: 'Alice' })
})

// PUT - Replace a user
fetch('/api/users/123', {
  method: 'PUT',
  body: JSON.stringify({ name: 'Alice Updated' })
})

// DELETE - Remove a user
fetch('/api/users/123', {
  method: 'DELETE'
})
```

### HTTP Status Codes: What Happened?

Status codes are three-digit numbers that tell you how the request went:

<AccordionGroup>
  <Accordion title="2xx - Success">
    The request was received, understood, and accepted.
    
    - **200 OK** — Standard success response
    - **201 Created** — New resource was created (common after POST)
    - **204 No Content** — Success, but nothing to return (common after DELETE)
    
    ```javascript
    // 200 OK example
    const response = await fetch('/api/users/123')
    console.log(response.status)  // 200
    console.log(response.ok)      // true
    ```
  </Accordion>
  
  <Accordion title="3xx - Redirection">
    The resource has moved somewhere else.
    
    - **301 Moved Permanently** — Resource has a new permanent URL
    - **302 Found** — Temporary redirect
    - **304 Not Modified** — Use your cached version
    
    Fetch follows redirects automatically by default.
  </Accordion>
  
  <Accordion title="4xx - Client Errors">
    Something is wrong with your request.
    
    - **400 Bad Request** — Malformed request syntax
    - **401 Unauthorized** — Authentication required
    - **403 Forbidden** — You don't have permission
    - **404 Not Found** — Resource doesn't exist
    - **422 Unprocessable Entity** — Validation failed
    
    ```javascript
    // 404 Not Found example
    const response = await fetch('/api/users/999999')
    console.log(response.status)  // 404
    console.log(response.ok)      // false
    ```
  </Accordion>
  
  <Accordion title="5xx - Server Errors">
    Something went wrong on the server.
    
    - **500 Internal Server Error** — Generic server error
    - **502 Bad Gateway** — Server got invalid response from upstream
    - **503 Service Unavailable** — Server is overloaded or down for maintenance
    
    ```javascript
    // 500 error example
    const response = await fetch('/api/broken-endpoint')
    console.log(response.status)  // 500
    console.log(response.ok)      // false
    ```
  </Accordion>
</AccordionGroup>

<Tip>
**Quick Rule of Thumb:**
- **2xx** = "Here's what you asked for"
- **3xx** = "Go look over there"
- **4xx** = "You messed up"
- **5xx** = "We messed up"
</Tip>

---

## The Fetch API

The **Fetch API** is JavaScript's modern way to make HTTP requests. It replaced the older `XMLHttpRequest` (XHR) with a cleaner, Promise-based interface.

### Basic GET Request

The simplest fetch call retrieves data from a URL:

```javascript
// Basic fetch - returns a Promise
fetch('https://api.example.com/users')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error))
```

Let's break this down step by step:

```javascript
// Step 1: fetch() returns a Promise that resolves to a Response object
const responsePromise = fetch('https://api.example.com/users')

// Step 2: When the response arrives, we get a Response object
responsePromise.then(response => {
  console.log(response.status)      // 200
  console.log(response.ok)          // true
  console.log(response.headers)     // Headers object
  
  // Step 3: The body is a stream, we need to parse it
  // .json() returns ANOTHER Promise
  return response.json()
})
.then(data => {
  // Step 4: Now we have the actual data
  console.log(data)  // { users: [...] }
})
```

### The Response Object

When `fetch()` resolves, you get a `Response` object with useful properties:

```javascript
const response = await fetch('https://api.example.com/users/1')

// Status information
response.status      // 200, 404, 500, etc.
response.statusText  // "OK", "Not Found", "Internal Server Error"
response.ok          // true if status is 200-299

// Response metadata
response.headers     // Headers object
response.url         // Final URL (after redirects)
response.type        // "basic", "cors", etc.
response.redirected  // true if response came from a redirect

// Body methods (each returns a Promise)
response.json()      // Parse body as JSON
response.text()      // Parse body as plain text
response.blob()      // Parse body as binary Blob
response.formData()  // Parse body as FormData
response.arrayBuffer() // Parse body as ArrayBuffer
```

<Warning>
**Important:** The body can only be read once! If you call `response.json()`, you can't call `response.text()` afterward. If you need to read it multiple times, clone the response first with `response.clone()`.
</Warning>

### Reading JSON Data

Most APIs return JSON. Use `.json()` to parse it:

```javascript
async function getUser(id) {
  const response = await fetch(`https://api.example.com/users/${id}`)
  const user = await response.json()
  
  console.log(user.name)   // "Alice"
  console.log(user.email)  // "alice@example.com"
  
  return user
}
```

### Making POST Requests

To send data to a server, use the POST method with a request body:

```javascript
async function createUser(userData) {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(userData)
  })
  
  const newUser = await response.json()
  return newUser
}

// Usage
const user = await createUser({
  name: 'Bob',
  email: 'bob@example.com'
})
console.log(user.id)  // New user's ID from server
```

### Setting Headers

Headers provide additional information about the request:

```javascript
const response = await fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    // Tell server what format we want
    'Accept': 'application/json',
    
    // Authentication token
    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIs...',
    
    // Custom header
    'X-Custom-Header': 'custom-value'
  }
})
```

Common headers you'll use:

| Header | Purpose |
|--------|---------|
| `Content-Type` | Format of data you're sending (e.g., `application/json`) |
| `Accept` | Format of data you want back |
| `Authorization` | Authentication credentials |
| `Cache-Control` | Caching instructions |

### Building URLs with Query Parameters

When fetching data, you often need to include query parameters (e.g., `/api/search?q=javascript&page=1`). Use the **[URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)** and **[URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)** APIs to build URLs safely:

```javascript
// Building a URL with query parameters
const url = new URL('https://api.example.com/search')
url.searchParams.set('q', 'javascript')
url.searchParams.set('page', '1')
url.searchParams.set('limit', '10')

console.log(url.toString())
// "https://api.example.com/search?q=javascript&page=1&limit=10"

// Use with fetch
const response = await fetch(url)
```

You can also use `URLSearchParams` directly:

```javascript
const params = new URLSearchParams({
  q: 'javascript',
  page: '1'
})

// Append to a URL string
const response = await fetch(`/api/search?${params}`)
```

<Tip>
**Why use URL/URLSearchParams instead of string concatenation?** These APIs automatically handle URL encoding for special characters. If a user searches for "C++ tutorial", it becomes `q=C%2B%2B+tutorial` — something you'd have to handle manually with string concatenation.
</Tip>

---

## Error Handling: The Critical Distinction

This is the **most important section** of this guide. Many developers get this wrong, leading to bugs that are hard to track down.

### Two Types of "Errors"

When working with `fetch()`, there are two completely different types of failures:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         TWO TYPES OF FAILURES                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. NETWORK ERRORS                    2. HTTP ERROR RESPONSES            │
│  ────────────────────                 ───────────────────────            │
│                                                                          │
│  • Server unreachable                 • Server responded with error      │
│  • DNS lookup failed                  • 404 Not Found                    │
│  • No internet connection             • 500 Internal Server Error        │
│  • Request timed out                  • 401 Unauthorized                 │
│  • CORS blocked                       • 403 Forbidden                    │
│                                                                          │
│  Promise REJECTS ❌                   Promise RESOLVES ✓                 │
│  Goes to .catch()                     response.ok is false               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

<Warning>
**The Trap:** `fetch()` only rejects its Promise for network errors. An HTTP 404 or 500 response is still a "successful" fetch — the network request completed! You must check `response.ok` to detect HTTP errors.
</Warning>

### The Wrong Way

```javascript
// ❌ WRONG - This misses HTTP errors!
try {
  const response = await fetch('/api/users/999')
  const data = await response.json()
  console.log(data)  // Might be an error object!
} catch (error) {
  // Only catches NETWORK errors
  // A 404 response WON'T end up here!
  console.error('Error:', error)
}
```

### The Right Way

```javascript
// ✓ CORRECT - Check response.ok
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`)
    
    // Check if the HTTP response was successful
    if (!response.ok) {
      // HTTP error (4xx, 5xx) - throw to catch block
      throw new Error(`HTTP error! Status: ${response.status}`)
    }
    
    const data = await response.json()
    return data
    
  } catch (error) {
    // Now this catches BOTH network errors AND HTTP errors
    console.error('Fetch failed:', error.message)
    throw error
  }
}
```

### A Reusable Fetch Wrapper

Here's a pattern you can use in real projects:

```javascript
async function fetchJSON(url, options = {}) {
  const response = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    },
    ...options
  })
  
  // Handle HTTP errors
  if (!response.ok) {
    const error = new Error(`HTTP ${response.status}: ${response.statusText}`)
    error.status = response.status
    error.response = response
    throw error
  }
  
  // Handle empty responses (like 204 No Content)
  if (response.status === 204) {
    return null
  }
  
  return response.json()
}

// Usage
try {
  const user = await fetchJSON('/api/users/1')
  console.log(user)
} catch (error) {
  if (error.status === 404) {
    console.log('User not found')
  } else if (error.status >= 500) {
    console.log('Server error, try again later')
  } else {
    console.log('Request failed:', error.message)
  }
}
```

---

## Modern Patterns with async/await

While `fetch()` works with `.then()` chains, modern JavaScript uses `async/await` for cleaner code.

### Basic async/await Pattern

```javascript
async function loadUserProfile(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`)
    
    if (!response.ok) {
      throw new Error(`Failed to load user: ${response.status}`)
    }
    
    const user = await response.json()
    return user
    
  } catch (error) {
    console.error('Error loading profile:', error)
    return null
  }
}

// Usage
const user = await loadUserProfile(123)
if (user) {
  console.log(`Welcome, ${user.name}!`)
}
```

### Parallel Requests

Need to fetch multiple resources? Don't await them one by one:

```javascript
// ❌ SLOW - Sequential requests (one after another)
async function loadDashboardSlow() {
  const user = await fetch('/api/user').then(r => r.json())
  const posts = await fetch('/api/posts').then(r => r.json())
  const notifications = await fetch('/api/notifications').then(r => r.json())
  // Total time: user + posts + notifications
  return { user, posts, notifications }
}

// ✓ FAST - Parallel requests (all at once)
async function loadDashboardFast() {
  const [user, posts, notifications] = await Promise.all([
    fetch('/api/user').then(r => r.json()),
    fetch('/api/posts').then(r => r.json()),
    fetch('/api/notifications').then(r => r.json())
  ])
  // Total time: max(user, posts, notifications)
  return { user, posts, notifications }
}
```

### Loading States Pattern

In real applications, you need to track loading and error states:

```javascript
async function fetchWithState(url) {
  const state = {
    data: null,
    loading: true,
    error: null
  }
  
  try {
    const response = await fetch(url)
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`)
    }
    
    state.data = await response.json()
  } catch (error) {
    state.error = error.message
  } finally {
    state.loading = false
  }
  
  return state
}

// Usage
const result = await fetchWithState('/api/users')

if (result.loading) {
  console.log('Loading...')
} else if (result.error) {
  console.log('Error:', result.error)
} else {
  console.log('Data:', result.data)
}
```

---

## Cancelling Requests with AbortController

The **[AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)** API lets you cancel in-flight fetch requests. This is essential for:

- **Timeouts** — Cancel requests that take too long
- **User navigation** — Cancel pending requests when user leaves a page
- **Search inputs** — Cancel the previous search when user types new characters
- **Component cleanup** — Cancel requests when a React/Vue component unmounts

Without AbortController, abandoned requests continue running in the background, wasting bandwidth and potentially causing bugs when their responses arrive after you no longer need them.

### How It Works

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         ABORTCONTROLLER FLOW                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   1. Create controller         2. Pass signal to fetch                   │
│   ┌─────────────────────┐      ┌─────────────────────────────────┐       │
│   │ const controller =  │      │ fetch(url, {                    │       │
│   │   new AbortController│ ───► │   signal: controller.signal    │       │
│   └─────────────────────┘      │ })                              │       │
│                                └─────────────────────────────────┘       │
│                                                                          │
│   3. Call abort() to cancel    4. Fetch rejects with AbortError          │
│   ┌─────────────────────┐      ┌─────────────────────────────────┐       │
│   │ controller.abort()  │ ───► │ catch (error) {                 │       │
│   └─────────────────────┘      │   error.name === 'AbortError'   │       │
│                                │ }                               │       │
│                                └─────────────────────────────────┘       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Basic AbortController Usage

```javascript
// Create a controller
const controller = new AbortController()

// Pass its signal to fetch
fetch('/api/slow-endpoint', {
  signal: controller.signal
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled')
    } else {
      console.error('Request failed:', error)
    }
  })

// Cancel the request after 5 seconds
setTimeout(() => {
  controller.abort()
}, 5000)
```

### Timeout Pattern

Create a reusable timeout wrapper:

```javascript
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController()
  
  // Set up timeout
  const timeoutId = setTimeout(() => {
    controller.abort()
  }, timeout)
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    })
    
    clearTimeout(timeoutId)
    return response
    
  } catch (error) {
    clearTimeout(timeoutId)
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timed out after ${timeout}ms`)
    }
    
    throw error
  }
}

// Usage
try {
  const response = await fetchWithTimeout('/api/data', {}, 3000)
  const data = await response.json()
} catch (error) {
  console.error(error.message)  // "Request timed out after 3000ms"
}
```

### Search Input Pattern

Cancel previous search when user types:

```javascript
let currentController = null

async function searchUsers(query) {
  // Cancel any in-flight request
  if (currentController) {
    currentController.abort()
  }
  
  // Create new controller for this request
  currentController = new AbortController()
  
  try {
    const response = await fetch(`/api/search?q=${query}`, {
      signal: currentController.signal
    })
    
    if (!response.ok) throw new Error('Search failed')
    
    return await response.json()
    
  } catch (error) {
    if (error.name === 'AbortError') {
      // Ignore - we cancelled this on purpose
      return null
    }
    throw error
  }
}

// As user types, only the last request matters
searchInput.addEventListener('input', async (e) => {
  const results = await searchUsers(e.target.value)
  if (results) {
    displayResults(results)
  }
})
```

---

## Key Takeaways

<Info>
**Remember these essential points about HTTP & Fetch:**

1. **HTTP is request-response** — Client sends a request, server sends a response

2. **HTTP methods are verbs** — GET (read), POST (create), PUT (update), DELETE (remove)

3. **Status codes tell you what happened** — 2xx (success), 4xx (your fault), 5xx (server's fault)

4. **Fetch returns a Promise** — It resolves to a Response object, not directly to data

5. **Response.json() is also a Promise** — You need to await it too

6. **Fetch only rejects on network errors** — HTTP 404/500 still "succeeds" — check `response.ok`!

7. **Always check response.ok** — This is the most common fetch mistake

8. **Use async/await** — It's cleaner than Promise chains

9. **Use Promise.all for parallel requests** — Don't await sequentially when you don't have to

10. **AbortController cancels requests** — Essential for search inputs and cleanup
</Info>

---

## Test Your Knowledge

<AccordionGroup>
  <Accordion title="Question 1: What's the difference between a network error and an HTTP error in fetch?">
    **Answer:**
    
    - **Network errors** occur when the request can't be completed at all — server unreachable, DNS failure, no internet, CORS blocked, etc. These cause the fetch Promise to **reject**.
    
    - **HTTP errors** occur when the server responds with an error status code (4xx, 5xx). The request completed successfully (the network worked), so the Promise **resolves**. You must check `response.ok` to detect these.
    
    ```javascript
    try {
      const response = await fetch('/api/data')
      
      // This line runs even for 404, 500, etc.!
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      
      const data = await response.json()
    } catch (error) {
      // Now catches both types
    }
    ```
  </Accordion>
  
  <Accordion title="Question 2: Why does response.json() return a Promise?">
    **Answer:** The response body is a readable stream that might still be downloading when `fetch()` resolves. The `response.json()` method reads the entire stream and parses it as JSON, which is an asynchronous operation.
    
    This is why you need to `await` it:
    
    ```javascript
    const response = await fetch('/api/data')  // Response headers arrived
    const data = await response.json()         // Body fully downloaded & parsed
    ```
    
    The same applies to `response.text()`, `response.blob()`, etc.
  </Accordion>
  
  <Accordion title="Question 3: How do you send JSON data in a POST request?">
    **Answer:** You need to:
    1. Set the method to 'POST'
    2. Set the Content-Type header to 'application/json'
    3. Stringify your data in the body
    
    ```javascript
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: 'Alice',
        email: 'alice@example.com'
      })
    })
    ```
  </Accordion>
  
  <Accordion title="Question 4: What does response.ok mean?">
    **Answer:** `response.ok` is a boolean that's `true` if the HTTP status code is in the 200-299 range (success), and `false` otherwise.
    
    It's a convenient shorthand for checking if the request succeeded:
    
    ```javascript
    // These are equivalent:
    if (response.ok) { ... }
    if (response.status >= 200 && response.status < 300) { ... }
    ```
    
    Common values:
    - 200, 201, 204 → `ok` is `true`
    - 400, 401, 404, 500 → `ok` is `false`
  </Accordion>
  
  <Accordion title="Question 5: How do you cancel a fetch request?">
    **Answer:** Use an `AbortController`:
    
    ```javascript
    // 1. Create controller
    const controller = new AbortController()
    
    // 2. Pass its signal to fetch
    fetch('/api/data', { signal: controller.signal })
      .then(r => r.json())
      .catch(error => {
        if (error.name === 'AbortError') {
          console.log('Cancelled!')
        }
      })
    
    // 3. Call abort() to cancel
    controller.abort()
    ```
    
    Common use cases:
    - Timeout implementation
    - Cancelling when user navigates away
    - Cancelling previous search when user types new input
  </Accordion>
  
  <Accordion title="Question 6: How do you make multiple fetch requests in parallel?">
    **Answer:** Use `Promise.all()` to run requests concurrently:
    
    ```javascript
    // ✓ Parallel - fast
    const [users, posts, comments] = await Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/posts').then(r => r.json()),
      fetch('/api/comments').then(r => r.json())
    ])
    
    // ❌ Sequential - slow (each waits for the previous)
    const users = await fetch('/api/users').then(r => r.json())
    const posts = await fetch('/api/posts').then(r => r.json())
    const comments = await fetch('/api/comments').then(r => r.json())
    ```
    
    Parallel requests complete in the time of the slowest request, not the sum of all requests.
  </Accordion>
</AccordionGroup>

---

## Related Concepts

<CardGroup cols={2}>
  <Card title="Promises" icon="handshake" href="/concepts/promises">
    Fetch is Promise-based — understanding Promises is essential
  </Card>
  <Card title="async/await" icon="hourglass" href="/concepts/async-await">
    Modern syntax for working with Promises and fetch
  </Card>
  <Card title="Event Loop" icon="arrows-spin" href="/concepts/event-loop">
    How JavaScript handles async operations like fetch
  </Card>
  <Card title="DOM" icon="sitemap" href="/concepts/dom">
    Often you'll fetch data and update the DOM with it
  </Card>
</CardGroup>

---

## Reference

<CardGroup cols={2}>
  <Card title="Fetch API — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">
    Official MDN documentation for the Fetch API
  </Card>
  <Card title="Using Fetch — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">
    Comprehensive guide to using the Fetch API
  </Card>
  <Card title="Response — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Response">
    Documentation for the Response object
  </Card>
  <Card title="AbortController — MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">
    Documentation for cancelling fetch requests
  </Card>
</CardGroup>

## Articles

<CardGroup cols={2}>
  <Card title="How to Use Fetch with async/await" icon="newspaper" href="https://dmitripavlutin.com/javascript-fetch-async-await/">
    Dmitri Pavlutin's clear guide to modern fetch patterns with practical examples.
  </Card>
  <Card title="JavaScript Fetch API Ultimate Guide" icon="newspaper" href="https://blog.webdevsimplified.com/2022-01/js-fetch-api/">
    Web Dev Simplified's comprehensive tutorial covering all fetch fundamentals.
  </Card>
  <Card title="Fetch API Error Handling" icon="newspaper" href="https://www.tjvantoll.com/2015/09/13/fetch-and-errors/">
    TJ VanToll's essential article on the fetch error handling gotcha that trips up everyone.
  </Card>
  <Card title="Abort Controller: Why and How" icon="newspaper" href="https://blog.openreplay.com/abort-controller--why-and-how-to-use-it/">
    OpenReplay's guide to cancelling fetch requests with AbortController.
  </Card>
</CardGroup>

## Videos

<CardGroup cols={2}>
  <Card title="JavaScript Fetch API" icon="video" href="https://www.youtube.com/watch?v=cuEtnrL9-H0">
    Traversy Media's beginner-friendly introduction to the Fetch API.
  </Card>
  <Card title="Learn Fetch API in 6 Minutes" icon="video" href="https://www.youtube.com/watch?v=37vxWr0WgQk">
    Web Dev Simplified's quick and clear fetch tutorial.
  </Card>
  <Card title="Async JS Crash Course - Callbacks, Promises, Async/Await" icon="video" href="https://www.youtube.com/watch?v=PoRJizFvM7s">
    Traversy Media's comprehensive async JavaScript guide including fetch.
  </Card>
  <Card title="JavaScript Fetch with Request and Headers Objects" icon="video" href="https://www.youtube.com/watch?v=CVZhFBjn8Rw">
    Steve Griffith's detailed walkthrough of fetch's Request and Headers APIs.
  </Card>
</CardGroup>
