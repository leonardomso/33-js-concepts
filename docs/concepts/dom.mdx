---
title: "DOM and Layout Trees"
description: "Understanding the Document Object Model and how browsers render pages"
---

How does JavaScript change what you see on a webpage? How do you click a button and see new content appear, or type in a form and watch suggestions pop up? How does a "dark mode" toggle instantly transform an entire page?

The **[Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)** is a programming interface for web documents. It represents your HTML as a **tree of objects** that JavaScript can read and manipulate.

```javascript
// The DOM lets you do things like this:
document.querySelector('h1').textContent = 'Hello, DOM!'
document.body.style.backgroundColor = 'lightblue'
document.getElementById('btn').addEventListener('click', handleClick)
```

With the DOM, you can use methods like **[`querySelector()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector)** to find elements, **[`getElementById()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById)** to grab specific nodes, and **[`addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)** to respond to user interactions.

<Info>
**What you'll learn in this guide:**
- What the DOM actually is (and what it's NOT)
- How to select elements like a pro (getElementById vs querySelector)
- How to traverse the tree (parent, children, siblings)
- How to create, modify, and remove elements
- The difference between properties and attributes
- How the browser turns DOM â†’ pixels (the Critical Rendering Path)
- Performance best practices (avoid layout thrashing!)
</Info>

---

## The Family Tree: Understanding DOM Structure

Think of the DOM like a family tree. At the top sits `document` (the family historian who knows everyone). Below it is `<html>` (the matriarch), which has two children: `<head>` and `<body>`. Each of these has their own children, grandchildren, and so on.

```
                           THE DOM FAMILY TREE

                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ document â”‚  â† The family historian
                              â”‚ (root)   â”‚    (knows everyone!)
                              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                   â”‚
                              â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                              â”‚  <html>  â”‚  â† Great-grandma
                              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    (the matriarch)
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚                           â”‚
                â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                â”‚ <head>  â”‚                 â”‚ <body>  â”‚  â† The two branches
                â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    of the family
                     â”‚                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚             â”‚         â”‚          â”‚          â”‚
         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”
         â”‚ <title> â”‚  â”‚ <meta>  â”‚ â”‚ <nav> â”‚ â”‚ <main>  â”‚ â”‚<footer>â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                       â”‚          â”‚
         "My Page"               â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”  â”Œâ”€â”€â”´â”€â”€â”
          (text)                 â”‚  <ul>   â”‚  â”‚<div>â”‚  â† Cousins
                                 â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”˜
                                      â”‚          â”‚
                                 â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”    ...
                                 â”‚    â”‚    â”‚
                               <li> <li> <li>   â† Siblings
```

Just like navigating a family reunion, the DOM lets you:

| Action | Family Analogy | DOM Method |
|--------|----------------|------------|
| Find your parent | "Who's your mom?" | `element.parentNode` |
| Find your kids | "Where are your children?" | `element.children` |
| Find your sibling | "Who's your brother?" | `element.nextElementSibling` |
| Search the whole family | "Where's cousin Bob?" | `document.querySelector('#bob')` |

<Note>
**Key insight:** Every element, text, and comment in your HTML becomes a "node" in this tree. JavaScript lets you navigate this tree and modify it â€” changing content, adding elements, or removing them entirely.
</Note>

---

## What the DOM is NOT

### The DOM is NOT Your HTML Source Code

This is a crucial distinction! Your HTML file and the DOM are **different things**:

<Tabs>
  <Tab title="HTML Source">
    ```html
    <!-- What you wrote (invalid HTML - missing head/body) -->
    <!DOCTYPE html>
    <html>
    Hello, World!
    </html>
    ```
  </Tab>
  <Tab title="Resulting DOM">
    ```html
    <!-- What the browser creates (fixed!) -->
    <!DOCTYPE html>
    <html>
      <head></head>
      <body>
        Hello, World!
      </body>
    </html>
    ```
  </Tab>
</Tabs>

The browser **fixes your mistakes**! It adds missing `<head>` and `<body>` tags, closes unclosed tags, and corrects nesting errors. The DOM is the corrected version.

### The DOM is NOT What You See in DevTools (Exactly)

DevTools shows you something close to the DOM, but it also shows **CSS pseudo-elements** (`::before`, `::after`) which are NOT part of the DOM:

```css
/* This creates visual content, but NOT DOM nodes */
.quote::before {
  content: '"';
}
```

Pseudo-elements exist in the **render tree** (for display), but not in the DOM (for JavaScript). You can't select them with `querySelector`!

### The DOM is NOT the Render Tree

The **Render Tree** is what actually gets painted to the screen. It excludes:

```html
<!-- These are in the DOM but NOT in the Render Tree -->
<head>...</head>                    <!-- Never rendered -->
<script>...</script>                <!-- Never rendered -->
<div style="display: none">Hidden</div>  <!-- Excluded from render -->
```

```
DOM                          Render Tree
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ <html>              â”‚     â”‚ <html>              â”‚
â”‚   <head>            â”‚     â”‚   <body>            â”‚
â”‚     <title>         â”‚     â”‚     <h1>            â”‚
â”‚   <body>            â”‚     â”‚       "Hello"       â”‚
â”‚     <h1>Hello</h1>  â”‚     â”‚     <p>             â”‚
â”‚     <p>World</p>    â”‚     â”‚       "World"       â”‚
â”‚     <div hidden>    â”‚     â”‚                     â”‚
â”‚       Secret!       â”‚     â”‚  (no hidden div!)   â”‚
â”‚     </div>          â”‚     â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The `document` Object: Your Entry Point

The **[`document`](https://developer.mozilla.org/en-US/docs/Web/API/Document)** object is your gateway to the DOM. It's automatically available in any browser JavaScript:

```javascript
// document is the root of everything
console.log(document);                    // The entire document
console.log(document.documentElement);    // <html> element
console.log(document.head);               // <head> element
console.log(document.body);               // <body> element
console.log(document.title);              // Page title (getter/setter!)

// You can modify the document
document.title = 'New Title';             // Changes browser tab title
```

---

## DOM Tree Structure & Node Types

Everything in the DOM is a **[Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)**. But not all nodes are created equal!

### The Node Type Hierarchy

```
                            Node (base class)
                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚                     â”‚
    Document             Element              CharacterData
        â”‚                     â”‚                     â”‚
   HTMLDocument          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                         â”‚         â”‚         â”‚           â”‚
                   HTMLElement  SVGElement  Text      Comment
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                â”‚                â”‚
  HTMLDivElement  HTMLSpanElement  HTMLInputElement
                                        ...
```

### Node Types You'll Encounter

| Node Type | `nodeType` | `nodeName` | Example |
|-----------|------------|------------|---------|
| [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) | `1` | Tag name (uppercase) | `<div>`, `<p>`, `<span>` |
| [Text](https://developer.mozilla.org/en-US/docs/Web/API/Text) | `3` | `#text` | Text inside elements |
| [Comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment) | `8` | `#comment` | `<!-- comment -->` |
| [Document](https://developer.mozilla.org/en-US/docs/Web/API/Document) | `9` | `#document` | The `document` object |
| [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) | `11` | `#document-fragment` | Virtual container |

```javascript
const div = document.createElement('div')
console.log(div.nodeType)   // 1 (Element)
console.log(div.nodeName)   // "DIV"

const text = document.createTextNode('Hello')
console.log(text.nodeType)  // 3 (Text)
console.log(text.nodeName)  // "#text"

console.log(document.nodeType)  // 9 (Document)
console.log(document.nodeName)  // "#document"
```

The **[`createElement()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)** and **[`createTextNode()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode)** methods create new nodes that you can add to the DOM.

### Node Type Constants

Instead of remembering numbers, use the constants:

```javascript
Node.ELEMENT_NODE        // 1
Node.TEXT_NODE           // 3
Node.COMMENT_NODE        // 8
Node.DOCUMENT_NODE       // 9
Node.DOCUMENT_FRAGMENT_NODE  // 11

// Check if something is an element
if (node.nodeType === Node.ELEMENT_NODE) {
  console.log('This is an element!');
}
```

### Visualizing a Real DOM Tree

Given this HTML:

```html
<div id="container">
  <h1>Title</h1>
  <!-- A comment -->
  <p>Paragraph</p>
</div>
```

The actual DOM tree looks like this (including text nodes from whitespace!):

```
div#container
â”œâ”€â”€ #text (newline + spaces)
â”œâ”€â”€ h1
â”‚   â””â”€â”€ #text "Title"
â”œâ”€â”€ #text (newline + spaces)
â”œâ”€â”€ #comment " A comment "
â”œâ”€â”€ #text (newline + spaces)
â”œâ”€â”€ p
â”‚   â””â”€â”€ #text "Paragraph"
â””â”€â”€ #text (newline)
```

<Warning>
**The Whitespace Gotcha!** Line breaks and spaces between HTML tags create **text nodes**. This surprises many developers! We'll see how to handle this in the traversal section.
</Warning>

---

## Selecting Elements

Before you can manipulate an element, you need to find it. JavaScript provides several methods through the **[`document`](https://developer.mozilla.org/en-US/docs/Web/API/Document)** object:

### The getElementById() Classic

The **[`getElementById()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById)** method is the fastest way to select a single element by its unique ID:

```javascript
// HTML: <div id="hero">Welcome!</div>

const hero = document.getElementById('hero')
console.log(hero)        // <div id="hero">Welcome!</div>
console.log(hero.id)     // "hero"
console.log(hero.textContent)  // "Welcome!"

// Returns null if not found (not an error!)
const ghost = document.getElementById('nonexistent')
console.log(ghost)  // null
```

<Tip>
IDs must be unique in a document. If you have duplicate IDs, `getElementById` returns the first one. But don't do thisâ€”it's invalid HTML!
</Tip>

### getElementsByClassName() and getElementsByTagName()

**[`getElementsByClassName()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName)** and **[`getElementsByTagName()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByTagName)** select multiple elements by class or tag name:

```javascript
// HTML: 
// <p class="intro">First</p>
// <p class="intro">Second</p>
// <p>Third</p>

const intros = document.getElementsByClassName('intro')
console.log(intros.length)      // 2
console.log(intros[0])          // <p class="intro">First</p>
console.log(intros[0].textContent)  // "First"

const allParagraphs = document.getElementsByTagName('p')
console.log(allParagraphs.length)  // 3
```

### The Modern Way: querySelector() and querySelectorAll()

**[`querySelector()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector)** and **[`querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll)** use CSS selectors to find elementsâ€”much more powerful!

```javascript
// querySelector returns the FIRST match (or null)
const firstButton = document.querySelector('button')      // First <button> element
const submitBtn = document.querySelector('#submit')       // Element with id="submit"
const firstCard = document.querySelector('.card')         // First element with class="card"
const navLink = document.querySelector('nav a.active')    // <a class="active"> inside <nav>
const dataItem = document.querySelector('[data-id="123"]')  // Element with data-id="123"

// querySelectorAll returns ALL matches (NodeList)
const allButtons = document.querySelectorAll('button')    // All <button> elements
const allCards = document.querySelectorAll('.card')       // All elements with class="card"
const evenRows = document.querySelectorAll('tr:nth-child(even)')  // Every even table row
```

### Selector Examples

```javascript
// By ID
document.querySelector('#main')

// By class
document.querySelector('.active')
document.querySelectorAll('.btn.primary')

// By tag
document.querySelector('header')
document.querySelectorAll('li')

// By attribute
document.querySelector('[type="submit"]')
document.querySelector('[data-modal="login"]')

// Descendant selectors
document.querySelector('nav ul li a')
document.querySelector('.sidebar .widget:first-child')

// Pseudo-selectors (limited support)
document.querySelectorAll('input:not([type="hidden"])')
document.querySelector('p:first-of-type')
```

### Live vs Static Collections

This is a crucial difference that trips up many developers. **[`getElementsByClassName()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName)** returns a live **[HTMLCollection](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection)**, while **[`querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll)** returns a static **[NodeList](https://developer.mozilla.org/en-US/docs/Web/API/NodeList)**:

```javascript
const liveList = document.getElementsByClassName('item')    // LIVE HTMLCollection
const staticList = document.querySelectorAll('.item')       // STATIC NodeList

// Start with 3 items
console.log(liveList.length)    // 3
console.log(staticList.length)  // 3

// Add a new item to the DOM
const newItem = document.createElement('div')
newItem.className = 'item'
document.body.appendChild(newItem)

// Check lengths again
console.log(liveList.length)    // 4 (automatically updated!)
console.log(staticList.length)  // 3 (still the old snapshot)
```

| Method | Returns | Live? |
|--------|---------|-------|
| `getElementById()` | Element or null | N/A |
| `getElementsByClassName()` | HTMLCollection | **Yes** (live) |
| `getElementsByTagName()` | HTMLCollection | **Yes** (live) |
| `querySelector()` | Element or null | N/A |
| `querySelectorAll()` | NodeList | **No** (static) |

### Scoped Selection

You can call selection methods on any element, not just `document`:

```javascript
const nav = document.querySelector('nav')

// Find links ONLY inside nav
const navLinks = nav.querySelectorAll('a')

// Find the active link inside nav
const activeLink = nav.querySelector('.active')
```

This is faster than searching the entire document and helps avoid selecting unintended elements.

### Performance Comparison

<AccordionGroup>
  <Accordion title="Which selector method is fastest?">
    In order of speed (fastest first):
    
    1. **`getElementById()`** - Direct hashtable lookup, O(1)
    2. **`getElementsByClassName()`** - Optimized internal lookup
    3. **`getElementsByTagName()`** - Optimized internal lookup
    4. **`querySelector()`** - Must parse CSS selector
    5. **`querySelectorAll()`** - Must parse and find all matches
    
    However, for most applications, **the difference is negligible**. Use `querySelector/querySelectorAll` for readability unless you're selecting thousands of elements in a loop.
    
    ```javascript
    // Premature optimization - don't do this
    const el1 = document.getElementById('myId')
    
    // This is fine and more readable
    const el2 = document.querySelector('#myId')
    ```
  </Accordion>
</AccordionGroup>

---

## Traversing the DOM

Once you have an element, you can navigate to related elements without querying the entire document.

### Traversing Downwards (To Children)

```javascript
const ul = document.querySelector('ul')

// Get ALL child nodes (including text nodes!)
const allChildNodes = ul.childNodes      // NodeList

// Get only ELEMENT children (usually what you want)
const elementChildren = ul.children       // HTMLCollection

// Get specific children
const firstChild = ul.firstChild          // First node (might be text!)
const firstElement = ul.firstElementChild // First ELEMENT child
const lastChild = ul.lastChild            // Last node
const lastElement = ul.lastElementChild   // Last ELEMENT child
```

<Warning>
**The Text Node Trap!** Look at this HTML:

```html
<ul>
  <li>One</li>
  <li>Two</li>
</ul>
```

What is `ul.firstChild`? It's NOT the first `<li>`! It's a **text node** containing the newline and spaces after `<ul>`. Use `firstElementChild` to get the actual `<li>` element.
</Warning>

### Traversing Upwards (To Parents)

```javascript
const li = document.querySelector('li')

// Direct parent
const parent = li.parentNode        // Usually same as parentElement
const parentEl = li.parentElement   // Guaranteed to be an Element (or null)

// Find ancestor matching selector (very useful!)
const form = li.closest('form')     // Finds nearest ancestor <form>
const card = li.closest('.card')    // Finds nearest ancestor with class "card"

// closest() includes the element itself
const self = li.closest('li')       // Returns li itself if it matches!
```

The **[`closest()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/closest)** method is incredibly useful for event delegation (see [Event Loop](/concepts/event-loop) for how events are processed):

```javascript
// Handle clicks on any button inside a card
document.addEventListener('click', (e) => {
  const card = e.target.closest('.card')
  if (card) {
    console.log('Clicked inside card:', card)
  }
})
```

### Traversing Sideways (To Siblings)

```javascript
const secondLi = document.querySelectorAll('li')[1]

// Previous/next nodes (might be text!)
const prevNode = secondLi.previousSibling
const nextNode = secondLi.nextSibling

// Previous/next ELEMENTS (usually what you want)
const prevElement = secondLi.previousElementSibling
const nextElement = secondLi.nextElementSibling

// Returns null at the boundaries
const firstLi = document.querySelector('li')
console.log(firstLi.previousElementSibling)  // null (no previous sibling)
```

### Node vs Element Properties Cheat Sheet

| Get... | Node Property (includes text) | Element Property (elements only) |
|--------|-------------------------------|----------------------------------|
| Parent | `parentNode` | `parentElement` |
| Children | `childNodes` | `children` |
| First child | `firstChild` | `firstElementChild` |
| Last child | `lastChild` | `lastElementChild` |
| Previous sibling | `previousSibling` | `previousElementSibling` |
| Next sibling | `nextSibling` | `nextElementSibling` |

<Tip>
**Rule of thumb:** Unless you specifically need text nodes, always use the Element variants (`children`, `firstElementChild`, `nextElementSibling`, etc.)
</Tip>

### Practical Example: Building a Breadcrumb Trail

```javascript
// Get all ancestors of an element
function getAncestors(element) {
  const ancestors = []
  let current = element.parentElement
  
  while (current && current !== document.body) {
    ancestors.push(current)
    current = current.parentElement
  }
  
  return ancestors
}

const deepElement = document.querySelector('.deeply-nested')
console.log(getAncestors(deepElement))
// [<div.parent>, <section>, <main>, ...]
```

---

## Creating and Manipulating Elements

The real power of the DOM is the ability to create, modify, and remove elements dynamically.

### Creating Elements

Use **[`createElement()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)** to create new elements and **[`createTextNode()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode)** to create text nodes:

```javascript
// Create a new element
const div = document.createElement('div')
const span = document.createElement('span')
const img = document.createElement('img')

// Create a text node
const text = document.createTextNode('Hello, world!')

// Create a comment node
const comment = document.createComment('This is a comment')

// Elements are created "detached" - not yet in the DOM!
console.log(div.parentNode)  // null
```

### Adding Elements to the DOM

There are many ways to add elements. Here's a comprehensive overview using methods like **[`appendChild()`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)**, **[`insertBefore()`](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore)**, **[`append()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/append)**, and **[`prepend()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/prepend)**:

<Tabs>
  <Tab title="appendChild()">
    Adds a node as the **last child** of a parent:
    
    ```javascript
    const ul = document.querySelector('ul')
    const li = document.createElement('li')
    li.textContent = 'New item'
    
    ul.appendChild(li)
    // <ul>
    //   <li>Existing</li>
    //   <li>New item</li>  â† Added at the end
    // </ul>
    ```
  </Tab>
  <Tab title="insertBefore()">
    Inserts a node **before** a reference node:
    
    ```javascript
    const ul = document.querySelector('ul')
    const existingLi = ul.querySelector('li')
    const newLi = document.createElement('li')
    newLi.textContent = 'First!'
    
    ul.insertBefore(newLi, existingLi)
    // <ul>
    //   <li>First!</li>    â† Inserted before
    //   <li>Existing</li>
    // </ul>
    ```
  </Tab>
  <Tab title="append() / prepend()">
    Modern methods that accept multiple nodes AND strings:
    
    ```javascript
    const div = document.querySelector('div')
    
    // append() - adds to the END
    div.append('Text', document.createElement('span'), 'More text')
    
    // prepend() - adds to the START
    div.prepend(document.createElement('strong'))
    ```
  </Tab>
  <Tab title="before() / after()">
    Insert as siblings (not children):
    
    ```javascript
    const h1 = document.querySelector('h1')
    
    // Insert BEFORE h1 (as previous sibling)
    h1.before(document.createElement('nav'))
    
    // Insert AFTER h1 (as next sibling)
    h1.after(document.createElement('p'))
    ```
  </Tab>
</Tabs>

### insertAdjacentHTML() - The Swiss Army Knife

For inserting HTML strings, **[`insertAdjacentHTML()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML)** is powerful and fast:

```javascript
const div = document.querySelector('div')

// Four positions to insert:
div.insertAdjacentHTML('beforebegin', '<p>Before div</p>')
div.insertAdjacentHTML('afterbegin', '<p>First child of div</p>')
div.insertAdjacentHTML('beforeend', '<p>Last child of div</p>')
div.insertAdjacentHTML('afterend', '<p>After div</p>')
```

Visual representation:

```html
<!-- beforebegin -->
<div>
  <!-- afterbegin -->
  existing content
  <!-- beforeend -->
</div>
<!-- afterend -->
```

### Removing Elements

<Tabs>
  <Tab title="remove()">
    Modern and simpleâ€”element removes itself:
    
    ```javascript
    const element = document.querySelector('.to-remove')
    element.remove()  // Gone!
    ```
  </Tab>
  <Tab title="removeChild()">
    Classic methodâ€”remove via parent:
    
    ```javascript
    const parent = document.querySelector('ul')
    const child = parent.querySelector('li')
    parent.removeChild(child)
    
    // Or remove from any element
    element.parentNode.removeChild(element)
    ```
  </Tab>
</Tabs>

### Cloning Elements

Use **[`cloneNode()`](https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode)** to duplicate elements:

```javascript
const original = document.querySelector('.card')

// Shallow clone (element only, no children)
const shallow = original.cloneNode(false)

// Deep clone (element AND all descendants)
const deep = original.cloneNode(true)

// Clones are detached - must add to DOM
document.body.appendChild(deep)
```

<Warning>
**ID Collision!** If you clone an element with an ID, you'll have duplicate IDs in your document (invalid HTML). Remove or change the ID after cloning:

```javascript
const clone = original.cloneNode(true)
clone.id = ''  // Remove ID
// or
clone.id = 'new-unique-id'
```
</Warning>

### DocumentFragment - Batch Operations

When adding many elements, using a **[`DocumentFragment`](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)** is more efficient:

```javascript
// Bad: Multiple reflows
const ul = document.querySelector('ul')
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li')
  li.textContent = `Item ${i}`
  ul.appendChild(li)  // Triggers reflow each time!
}

// Good: Single reflow
const ul = document.querySelector('ul')
const fragment = document.createDocumentFragment()

for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li')
  li.textContent = `Item ${i}`
  fragment.appendChild(li)  // No reflow (fragment is detached)
}

ul.appendChild(fragment)  // Single reflow!
```

A `DocumentFragment` is a lightweight container that:
- Is not part of the DOM tree
- Has no parent
- When appended, only its **children** are inserted (the fragment itself disappears)

---

## Modifying Content

Three properties let you read and write element content: **[`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)**, **[`textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent)**, and **[`innerText`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText)**.

### innerHTML - Parse and Insert HTML

```javascript
const div = document.querySelector('div')

// Read HTML content
console.log(div.innerHTML)  // "<p>Hello</p><span>World</span>"

// Write HTML content (parses the string!)
div.innerHTML = '<h1>New Title</h1><p>New paragraph</p>'

// Clear all content
div.innerHTML = ''
```

<Warning>
**Security Alert: XSS Vulnerability!**

Never use `innerHTML` with user-provided content:

```javascript
// DANGEROUS! User could inject: <img src=x onerror="stealCookies()">
div.innerHTML = userInput  // NO!

// Safe alternatives:
div.textContent = userInput  // Escapes HTML
// or sanitize the input first
```
</Warning>

### textContent - Plain Text Only

```javascript
const div = document.querySelector('div')

// Read text (ignores HTML tags)
// <div><p>Hello</p><span>World</span></div>
console.log(div.textContent)  // "HelloWorld"

// Write text (HTML is escaped, not parsed)
div.textContent = '<script>alert("XSS")</script>'
// Displays literally: <script>alert("XSS")</script>
// Safe from XSS!
```

### innerText - Rendered Text

```javascript
const div = document.querySelector('div')

// innerText respects CSS visibility
// <div>Hello <span style="display:none">Hidden</span> World</div>

console.log(div.textContent)  // "Hello Hidden World"
console.log(div.innerText)    // "Hello  World" (Hidden is excluded!)
```

### When to Use Each

| Property | Use Case |
|----------|----------|
| `innerHTML` | Inserting trusted HTML (never user input!) |
| `textContent` | Setting/getting plain text (safe, fast) |
| `innerText` | Getting text as user sees it (slower, respects CSS) |

```javascript
// Performance: textContent is faster than innerText
// because innerText must calculate styles

// Setting text content (both work, textContent is faster)
element.textContent = 'Hello'  // Preferred
element.innerText = 'Hello'    // Works but slower
```

---

## Working with Attributes

HTML elements have attributes. JavaScript lets you read, write, and remove them using **[`getAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute)**, **[`setAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute)**, **[`hasAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute)**, and **[`removeAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute)**.

### Standard Attribute Methods

```javascript
const link = document.querySelector('a')

// Get attribute value
const href = link.getAttribute('href')
const target = link.getAttribute('target')

// Set attribute value
link.setAttribute('href', 'https://example.com')
link.setAttribute('target', '_blank')

// Check if attribute exists
if (link.hasAttribute('target')) {
  console.log('Link opens in new tab')
}

// Remove attribute
link.removeAttribute('target')
```

### Properties vs Attributes: The Difference

This confuses many developers! **Attributes** are in the HTML. **Properties** are on the DOM object.

```html
<input type="text" value="initial">
```

```javascript
const input = document.querySelector('input')

// ATTRIBUTE: The original HTML value
console.log(input.getAttribute('value'))  // "initial"

// PROPERTY: The current state
console.log(input.value)  // "initial"

// User types "new text"...
console.log(input.getAttribute('value'))  // Still "initial"!
console.log(input.value)                  // "new text"

// Reset to attribute value
input.value = input.getAttribute('value')
```

Key differences:

| Aspect | Attribute | Property |
|--------|-----------|----------|
| Source | HTML markup | DOM object |
| Access | `get/setAttribute()` | Direct property access |
| Updates | Manual only | Automatically with user interaction |
| Type | Always string | Can be any type |

```javascript
// Attribute is always a string
checkbox.getAttribute('checked')  // "" or null

// Property is a boolean
checkbox.checked  // true or false

// Attribute (string)
input.getAttribute('maxlength')  // "10"

// Property (number)
input.maxLength  // 10
```

### Data Attributes and the dataset API

Custom data attributes start with `data-` and are accessible via the **[`dataset`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset)** property:

```html
<div id="user" 
     data-user-id="123" 
     data-role="admin"
     data-is-active="true">
  John Doe
</div>
```

```javascript
const user = document.querySelector('#user')

// Read data attributes (camelCase!)
console.log(user.dataset.userId)    // "123"
console.log(user.dataset.role)      // "admin"
console.log(user.dataset.isActive)  // "true" (string, not boolean!)

// Write data attributes
user.dataset.lastLogin = '2024-01-15'
// Creates: data-last-login="2024-01-15"

// Delete data attributes
delete user.dataset.role

// Check if exists
if ('userId' in user.dataset) {
  console.log('Has user ID')
}
```

<Tip>
**Naming Convention:** HTML uses `kebab-case` (`data-user-id`), JavaScript uses `camelCase` (`dataset.userId`). The conversion is automatic!
</Tip>

### Common Attribute Shortcuts

Many attributes have direct property shortcuts:

```javascript
// These pairs are equivalent:
element.id                    // element.getAttribute('id')
element.className             // element.getAttribute('class')
element.href                  // element.getAttribute('href')
element.src                   // element.getAttribute('src')
element.title                 // element.getAttribute('title')

// For class manipulation, use classList (covered next)
```

---

## Styling Elements

JavaScript can modify element styles in several ways using the **[`style`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)** property and **[`classList`](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)** API.

### The style Property (Inline Styles)

```javascript
const box = document.querySelector('.box')

// Set individual styles (camelCase!)
box.style.backgroundColor = 'blue'
box.style.fontSize = '20px'
box.style.marginTop = '10px'

// Read styles (only reads INLINE styles!)
console.log(box.style.backgroundColor)  // "blue"
console.log(box.style.color)            // "" (not inline, from stylesheet)

// Set multiple styles at once
box.style.cssText = 'background: red; font-size: 16px; padding: 10px;'

// Remove an inline style
box.style.backgroundColor = ''  // Removes the style
```

<Warning>
`element.style` only reads/writes **inline** styles! To get computed styles (from stylesheets), use `getComputedStyle()`.
</Warning>

### getComputedStyle() - Read Actual Styles

Use **[`getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)** to read the final computed styles:

```javascript
const box = document.querySelector('.box')

// Get all computed styles
const styles = getComputedStyle(box)

console.log(styles.backgroundColor)  // "rgb(0, 0, 255)"
console.log(styles.fontSize)         // "16px"
console.log(styles.display)          // "block"

// Get pseudo-element styles
const beforeStyles = getComputedStyle(box, '::before')
console.log(beforeStyles.content)    // '"Hello"'
```

### classList - Manipulate CSS Classes

The **[`classList`](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)** API is the modern way to add/remove/toggle classes:

```javascript
const button = document.querySelector('button')

// Add classes
button.classList.add('active')
button.classList.add('btn', 'btn-primary')  // Multiple at once

// Remove classes
button.classList.remove('active')
button.classList.remove('btn', 'btn-primary')  // Multiple at once

// Toggle (add if missing, remove if present)
button.classList.toggle('active')

// Toggle with condition
button.classList.toggle('active', isActive)  // Add if isActive is true

// Check if class exists
if (button.classList.contains('active')) {
  console.log('Button is active')
}

// Replace a class
button.classList.replace('btn-primary', 'btn-secondary')

// Iterate over classes
button.classList.forEach(cls => console.log(cls))

// Get number of classes
console.log(button.classList.length)  // 2
```

### className vs classList

```javascript
// className is a string (old way)
element.className = 'btn btn-primary'     // Replaces ALL classes
element.className += ' active'            // Appending is clunky

// classList is a DOMTokenList (modern way)
element.classList.add('active')           // Adds without affecting others
element.classList.remove('btn-primary')   // Removes specifically
```

---

## The Render Tree & Critical Rendering Path

Understanding how browsers render pages helps you write performant code. This is where [JavaScript Engines](/concepts/javascript-engines) and the browser's rendering engine work together.

### From HTML to Pixels

When you load a webpage, the browser goes through these steps:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     THE CRITICAL RENDERING PATH                              â”‚
â”‚                                                                              â”‚
â”‚  1. PARSE HTML          2. PARSE CSS           3. BUILD RENDER TREE         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  HTML bytes  â”‚      â”‚  CSS bytes   â”‚       â”‚  DOM    +   CSSOM    â”‚      â”‚
â”‚  â”‚      â†“       â”‚      â”‚      â†“       â”‚       â”‚    â†˜     â†™           â”‚      â”‚
â”‚  â”‚  Characters  â”‚      â”‚  Characters  â”‚       â”‚   RENDER TREE        â”‚      â”‚
â”‚  â”‚      â†“       â”‚      â”‚      â†“       â”‚       â”‚  (visible elements   â”‚      â”‚
â”‚  â”‚   Tokens     â”‚      â”‚   Tokens     â”‚       â”‚   + their styles)    â”‚      â”‚
â”‚  â”‚      â†“       â”‚      â”‚      â†“       â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚  â”‚    Nodes     â”‚      â”‚    Rules     â”‚                  â”‚                  â”‚
â”‚  â”‚      â†“       â”‚      â”‚      â†“       â”‚                  â–¼                  â”‚
â”‚  â”‚    DOM       â”‚      â”‚   CSSOM      â”‚       4. LAYOUT (Reflow)            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                                               â”‚ Calculate exact      â”‚      â”‚
â”‚                                               â”‚ position & size of   â”‚      â”‚
â”‚                                               â”‚ every element        â”‚      â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                          â”‚                  â”‚
â”‚                                                          â–¼                  â”‚
â”‚                                               5. PAINT                      â”‚
â”‚                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                                               â”‚ Fill in pixels:      â”‚      â”‚
â”‚                                               â”‚ colors, borders,     â”‚      â”‚
â”‚                                               â”‚ shadows, text        â”‚      â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                          â”‚                  â”‚
â”‚                                                          â–¼                  â”‚
â”‚                                               6. COMPOSITE                  â”‚
â”‚                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                                               â”‚ Combine layers into  â”‚      â”‚
â”‚                                               â”‚ final image (GPU)    â”‚      â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                          â”‚                  â”‚
â”‚                                                          â–¼                  â”‚
â”‚                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                                               â”‚      PIXELS!         â”‚      â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What's NOT in the Render Tree

The Render Tree only contains visible elements:

```html
<!-- NOT in Render Tree -->
<head>...</head>                    <!-- head is never rendered -->
<script>...</script>                <!-- script tags aren't visible -->
<link rel="stylesheet">             <!-- link tags aren't visible -->
<meta>                              <!-- meta tags aren't visible -->
<div style="display: none">Hi</div> <!-- display:none excluded -->

<!-- IN the Render Tree (even if not seen) -->
<div style="visibility: hidden">Hi</div>  <!-- Takes up space -->
<div style="opacity: 0">Hi</div>          <!-- Takes up space -->
```

### Layout (Reflow) - The Expensive Step

Layout calculates the **geometry** of every element: position, size, margins, etc.

**Reflow is triggered when:**
- Adding/removing elements
- Changing element dimensions (width, height, padding, margin)
- Changing font size
- Resizing the window
- Reading certain properties (more on this below!)

### Paint - Drawing Pixels

After layout, the browser paints the pixels: text, colors, images, borders, shadows.

**Repaint (without reflow) happens when:**
- Changing colors
- Changing background-image
- Changing visibility
- Changing box-shadow (sometimes)

### Composite - Layering

Modern browsers separate content into layers and use the GPU to composite them. This is why some animations are smooth:

```css
/* These properties can animate without reflow/repaint */
transform: translateX(100px);  /* GPU accelerated! */
opacity: 0.5;                   /* GPU accelerated! */

/* These properties cause reflow */
left: 100px;    /* Avoid for animations! */
width: 200px;   /* Avoid for animations! */
```

---

## Performance Best Practices

DOM operations can be slow. Here's how to keep your pages fast.

### Cache DOM References

```javascript
// Bad: Queries the DOM every iteration
for (let i = 0; i < 1000; i++) {
  document.querySelector('.result').textContent += i;
}

// Good: Query once, reuse
const result = document.querySelector('.result');
for (let i = 0; i < 1000; i++) {
  result.textContent += i;
}

// Even better: Build string, set once
const result = document.querySelector('.result');
let text = '';
for (let i = 0; i < 1000; i++) {
  text += i;
}
result.textContent = text;
```

### Batch DOM Updates

```javascript
// Bad: 3 separate reflows
element.style.width = '100px';
element.style.height = '200px';
element.style.margin = '10px';

// Good: Single reflow with cssText
element.style.cssText = 'width: 100px; height: 200px; margin: 10px;';

// Good: Single reflow with class
element.classList.add('my-styles');

// Good: DocumentFragment for multiple elements
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item;
  fragment.appendChild(li);
});
ul.appendChild(fragment);  // Single DOM update
```

### Avoid Layout Thrashing

**Layout thrashing** occurs when you alternate between reading and writing DOM properties:

```javascript
// TERRIBLE: Forces layout on EVERY iteration
boxes.forEach(box => {
  const width = box.offsetWidth;      // Read (forces layout)
  box.style.width = (width + 10) + 'px';  // Write (invalidates layout)
});

// GOOD: Batch reads, then batch writes
const widths = boxes.map(box => box.offsetWidth);  // Read all
boxes.forEach((box, i) => {
  box.style.width = (widths[i] + 10) + 'px';       // Write all
});
```

**Properties that trigger layout when read:**

```javascript
// Reading these forces the browser to calculate layout
element.offsetWidth     element.offsetHeight
element.offsetTop       element.offsetLeft
element.clientWidth     element.clientHeight
element.scrollWidth     element.scrollHeight
element.scrollTop       element.scrollLeft
element.getBoundingClientRect()
getComputedStyle(element)
```

### Use requestAnimationFrame for Visual Changes

Use **[`requestAnimationFrame()`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)** to batch visual changes with the browser's render cycle:

```javascript
// Bad: DOM changes at unpredictable times
window.addEventListener('scroll', () => {
  element.style.transform = `translateY(${window.scrollY}px)`
})

// Good: Batch visual changes with next frame
let ticking = false
window.addEventListener('scroll', () => {
  if (!ticking) {
    requestAnimationFrame(() => {
      element.style.transform = `translateY(${window.scrollY}px)`
      ticking = false
    })
    ticking = true
  }
})
```

---

## The #1 DOM Mistake: Using innerHTML with User Input

The most dangerous DOM mistake is using **[`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)** with untrusted content. This opens your application to **Cross-Site Scripting (XSS)** attacks.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    innerHTML: THE SECURITY TRAP                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  âŒ DANGEROUS                              âœ“ SAFE                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”€â”€â”€â”€â”€â”€                        â”‚
â”‚                                                                          â”‚
â”‚  User Input:                               User Input:                   â”‚
â”‚  "<img src=x onerror=alert('XSS')>"       "<img src=x onerror=...>"     â”‚
â”‚         â”‚                                        â”‚                       â”‚
â”‚         â–¼                                        â–¼                       â”‚
â”‚  element.innerHTML = userInput             element.textContent = input   â”‚
â”‚         â”‚                                        â”‚                       â”‚
â”‚         â–¼                                        â–¼                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ BROWSER PARSES  â”‚                      â”‚ DISPLAYED AS    â”‚            â”‚
â”‚  â”‚ AS REAL HTML!   â”‚                      â”‚ PLAIN TEXT      â”‚            â”‚
â”‚  â”‚                 â”‚                      â”‚                 â”‚            â”‚
â”‚  â”‚ ğŸš¨ Script runs! â”‚                      â”‚ "<img src=..."  â”‚            â”‚
â”‚  â”‚ Cookies stolen! â”‚                      â”‚ (harmless)      â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```javascript
// âŒ DANGEROUS - Never do this with user input!
const username = getUserInput()  // User enters: <img src=x onerror="stealCookies()">
div.innerHTML = `Welcome, ${username}!`
// The malicious script EXECUTES!

// âœ“ SAFE - textContent escapes HTML
const username = getUserInput()
div.textContent = `Welcome, ${username}!`
// Displays: Welcome, <img src=x onerror="stealCookies()">!
// The HTML is shown as text, not executed

// âœ“ SAFE - Create elements programmatically
const username = getUserInput()
const welcomeText = document.createTextNode(`Welcome, ${username}!`)
div.appendChild(welcomeText)
```

<Warning>
**The Trap:** `innerHTML` looks convenient, but it parses strings as real HTML. If that string contains user input, attackers can inject `<script>` tags, malicious event handlers, or other dangerous code. **Always use `textContent` for user-provided content.**
</Warning>

### Other Common Mistakes

<AccordionGroup>
  <Accordion title="Forgetting that querySelector returns null">
    ```javascript
    // âŒ WRONG - Crashes if element doesn't exist
    document.querySelector('.maybe-missing').classList.add('active')
    // TypeError: Cannot read property 'classList' of null
    
    // âœ“ CORRECT - Check first or use optional chaining
    const element = document.querySelector('.maybe-missing')
    if (element) {
      element.classList.add('active')
    }
    
    // Or use optional chaining (modern)
    document.querySelector('.maybe-missing')?.classList.add('active')
    ```
  </Accordion>
  
  <Accordion title="Using childNodes instead of children">
    ```javascript
    // âŒ CONFUSING - Includes whitespace text nodes!
    const ul = document.querySelector('ul')
    console.log(ul.childNodes.length)  // 7 (includes text nodes!)
    
    // âœ“ CLEAR - Only element children
    console.log(ul.children.length)  // 3 (just the <li> elements)
    ```
  </Accordion>
  
  <Accordion title="Layout thrashing in loops">
    ```javascript
    // âŒ SLOW - Forces layout on every iteration
    boxes.forEach(box => {
      const width = box.offsetWidth      // READ - forces layout
      box.style.width = width + 10 + 'px' // WRITE - invalidates layout
    })
    
    // âœ“ FAST - Batch reads, then batch writes
    const widths = boxes.map(box => box.offsetWidth)  // All reads
    boxes.forEach((box, i) => {
      box.style.width = widths[i] + 10 + 'px'          // All writes
    })
    ```
  </Accordion>
</AccordionGroup>

---

## Common Patterns

### Event Delegation

Instead of adding listeners to many elements, add one to a parent. This pattern relies on event bubbling (see [Event Loop](/concepts/event-loop) for how the browser processes events):

```javascript
// Bad: Many listeners
document.querySelectorAll('.btn').forEach(btn => {
  btn.addEventListener('click', handleClick)
})

// Good: One listener with delegation
document.querySelector('.button-container').addEventListener('click', (e) => {
  const btn = e.target.closest('.btn')
  if (btn) {
    handleClick(e)
  }
})
```

Benefits:
- Works for dynamically added elements
- Less memory usage
- Easier cleanup (uses [closures](/concepts/scope-and-closures) to maintain handler references)

### Checking if Element Exists

```javascript
// Using querySelector (returns null if not found)
const element = document.querySelector('.maybe-exists');
if (element) {
  element.textContent = 'Found!';
}

// Optional chaining (modern)
document.querySelector('.maybe-exists')?.classList.add('active');

// With getElementById
const el = document.getElementById('myId');
if (el !== null) {
  // Element exists
}
```

### Waiting for DOM Ready

Listen for the **[`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event)** event to know when the DOM is ready:

```javascript
// Modern: DOMContentLoaded (DOM ready, images may still be loading)
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM is ready!')
  // Safe to query elements
})

// Full page load (including images, stylesheets)
window.addEventListener('load', () => {
  console.log('Everything loaded!')
})

// If script is at end of body, DOM is already ready
// <script src="app.js"></script> <!-- Just before </body> -->

// Modern: defer attribute (script loads in parallel, runs after DOM ready)
// <script src="app.js" defer></script>
```

<Tip>
**Best practice:** Put your `<script>` tags just before `</body>` or use the `defer` attribute. Then you don't need to wait for DOMContentLoaded.
</Tip>

---

## Test Your Knowledge

<AccordionGroup>
  <Accordion title="Question 1: What's the difference between childNodes and children?">
    **Answer:**
    
    - `childNodes` returns ALL child nodes, including **text nodes** (whitespace!) and **comment nodes**
    - `children` returns only **element nodes**
    
    ```javascript
    // <ul>
    //   <li>One</li>
    //   <li>Two</li>
    // </ul>
    
    ul.childNodes.length;  // 5 (text, li, text, li, text)
    ul.children.length;    // 2 (li, li)
    ```
    
    **Rule:** Use `children` unless you specifically need text/comment nodes.
  </Accordion>
  
  <Accordion title="Question 2: Why is innerHTML dangerous with user input?">
    **Answer:** `innerHTML` parses strings as HTML, enabling **Cross-Site Scripting (XSS)** attacks:
    
    ```javascript
    // User input: <img src=x onerror="stealCookies()">
    div.innerHTML = userInput;  // Executes malicious code!
    
    // Safe: textContent escapes HTML
    div.textContent = userInput;  // Displays as plain text
    ```
    
    Always sanitize HTML or use `textContent` for user-provided content.
  </Accordion>
  
  <Accordion title="Question 3: What's the difference between getAttribute('value') and .value on an input?">
    **Answer:**
    
    - `getAttribute('value')` returns the **original HTML attribute** (initial value)
    - `.value` property returns the **current value** (what user typed)
    
    ```javascript
    // <input value="initial">
    // User types "hello"
    
    input.getAttribute('value');  // "initial"
    input.value;                  // "hello"
    ```
    
    Attributes are the HTML source. Properties are the live DOM state.
  </Accordion>
  
  <Accordion title="Question 4: What does closest() do and why is it useful?">
    **Answer:** `closest()` finds the nearest **ancestor** (including the element itself) that matches a selector:
    
    ```javascript
    // <div class="card">
    //   <button class="btn">Click</button>
    // </div>
    
    btn.closest('.card');  // Returns the parent div
    btn.closest('button'); // Returns btn itself (it matches!)
    btn.closest('.modal'); // null (no matching ancestor)
    ```
    
    **Super useful for event delegation:**
    
    ```javascript
    document.addEventListener('click', (e) => {
      const card = e.target.closest('.card');
      if (card) {
        // Handle click inside any card
      }
    });
    ```
  </Accordion>
  
  <Accordion title="Question 5: What causes layout thrashing and how do you avoid it?">
    **Answer:** Layout thrashing happens when you **alternate reading and writing** layout-triggering properties:
    
    ```javascript
    // BAD: Read-write-read-write pattern
    boxes.forEach(box => {
      const width = box.offsetWidth;     // READ â†’ forces layout
      box.style.width = width + 10 + 'px'; // WRITE â†’ invalidates layout
    });
    // Each iteration forces a new layout calculation!
    
    // GOOD: Batch reads, then batch writes
    const widths = boxes.map(b => b.offsetWidth);  // All reads
    boxes.forEach((box, i) => {
      box.style.width = widths[i] + 10 + 'px';     // All writes
    });
    // Only one layout calculation!
    ```
  </Accordion>
  
  <Accordion title="Question 6: What's in the Render Tree vs the DOM?">
    **Answer:** The DOM contains **all nodes** from the HTML (plus JS modifications). The Render Tree contains only **visible elements** with their computed styles.
    
    **In DOM but NOT in Render Tree:**
    - `<head>` and its contents
    - `<script>`, `<link>`, `<meta>` tags
    - Elements with `display: none`
    
    **In Render Tree:**
    - Visible elements
    - Elements with `visibility: hidden` (still take space)
    - Elements with `opacity: 0` (still take space)
    
    Pseudo-elements (`::before`, `::after`) are in the Render Tree but NOT in the DOM.
  </Accordion>
  
  <Accordion title="Question 7: getElementsByClassName vs querySelectorAll - what's different?">
    **Answer:**
    
    | Aspect | `getElementsByClassName` | `querySelectorAll` |
    |--------|--------------------------|-------------------|
    | Returns | HTMLCollection | NodeList |
    | **Live** | **Yes** (updates automatically) | **No** (static snapshot) |
    | Selector | Class name only | Any CSS selector |
    | Speed | Slightly faster | Slightly slower |
    
    ```javascript
    const live = document.getElementsByClassName('item');
    const staticList = document.querySelectorAll('.item');
    
    // Add new element with class="item"
    document.body.appendChild(newItem);
    
    live.length;       // Increased (live collection)
    staticList.length; // Same (static snapshot)
    ```
  </Accordion>
  
  <Accordion title="Question 8: How do you safely add many elements to the DOM?">
    **Answer:** Use a **DocumentFragment** to batch insertions:
    
    ```javascript
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < 1000; i++) {
      const li = document.createElement('li');
      li.textContent = `Item ${i}`;
      fragment.appendChild(li);  // No reflow (fragment is detached)
    }
    
    ul.appendChild(fragment);  // Single reflow!
    ```
    
    A DocumentFragment is a virtual container. When appended, only its children are insertedâ€”the fragment disappears.
    
    Alternative: Build HTML string and use `innerHTML` once (but sanitize if user input!).
  </Accordion>
</AccordionGroup>

---

## Key Takeaways

<Info>
**Remember these essential points:**

1. **The DOM is a tree** â€” Elements are nodes with parent, child, and sibling relationships

2. **DOM â‰  HTML source** â€” The browser fixes errors and JavaScript modifies it

3. **Use querySelector** â€” More flexible than getElementById, accepts any CSS selector

4. **Element vs Node properties** â€” Use `children`, `firstElementChild`, etc. to skip text nodes

5. **closest() is your friend** â€” Perfect for event delegation and finding ancestor elements

6. **innerHTML is dangerous** â€” Never use with user input; use textContent instead

7. **Attributes vs Properties** â€” Attributes are HTML source, properties are live DOM state

8. **classList over className** â€” Use add/remove/toggle for cleaner class manipulation

9. **Batch DOM operations** â€” Use DocumentFragment or build strings to minimize reflows

10. **Avoid layout thrashing** â€” Don't alternate reading and writing layout properties
</Info>

---

## Related Concepts

<CardGroup cols={2}>
  <Card title="Event Loop" icon="arrows-spin" href="/concepts/event-loop">
    How JavaScript handles async operations and DOM events
  </Card>
  <Card title="JavaScript Engines" icon="gear" href="/concepts/javascript-engines">
    How V8 and other engines parse and execute your DOM code
  </Card>
  <Card title="Scope and Closures" icon="layer-group" href="/concepts/scope-and-closures">
    Understanding variable scope in event handlers and callbacks
  </Card>
  <Card title="Design Patterns" icon="puzzle-piece" href="/concepts/design-patterns">
    Patterns like Observer for reactive DOM updates
  </Card>
</CardGroup>

---

## Reference

<CardGroup cols={2}>
  <Card title="Document Object Model (DOM) â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">
    The comprehensive MDN reference for all DOM interfaces, methods, and properties.
  </Card>
  <Card title="Document Interface â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Document">
    The Document interface representing the web page loaded in the browser.
  </Card>
  <Card title="Element Interface â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Element">
    The base class for all element objects in a Document.
  </Card>
  <Card title="Node Interface â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/Node">
    The abstract base class for DOM nodes including elements, text, and comments.
  </Card>
  <Card title="NodeList Interface â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">
    Collections of nodes returned by querySelectorAll and other methods.
  </Card>
  <Card title="HTMLCollection Interface â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection">
    Live collections of elements returned by getElementsByClassName and similar.
  </Card>
</CardGroup>

## Books

<Card title="Eloquent JavaScript, 3rd Edition: Ch. 14 - The Document Object Model" icon="book" href="https://eloquentjavascript.net/14_dom.html">
  Marijn Haverbeke's excellent free book chapter covering DOM fundamentals with clear explanations and exercises.
</Card>

## Articles

<CardGroup cols={2}>
  <Card title="How To Understand and Modify the DOM in JavaScript" icon="newspaper" href="https://www.digitalocean.com/community/tutorials/introduction-to-the-dom">
    Tania Rascia's beginner-friendly guide covering DOM basics, selection, traversal, and manipulation.
  </Card>
  <Card title="What's the Document Object Model, and why you should know how to use it" icon="newspaper" href="https://medium.freecodecamp.org/whats-the-document-object-model-and-why-you-should-know-how-to-use-it-1a2d0bc5429d">
    A practical introduction to the DOM with real-world examples.
  </Card>
  <Card title="What is the DOM?" icon="newspaper" href="https://css-tricks.com/dom/">
    Chris Coyier's clear explanation of what the DOM is and common misconceptions.
  </Card>
  <Card title="Traversing the DOM with JavaScript" icon="newspaper" href="https://zellwk.com/blog/dom-traversals/">
    Zell Liew's detailed guide to navigating parent, child, and sibling elements efficiently.
  </Card>
  <Card title="DOM Tree" icon="newspaper" href="https://javascript.info/dom-nodes">
    JavaScript.info's comprehensive tutorial on DOM structure, node types, and tree navigation.
  </Card>
  <Card title="How to traverse the DOM in JavaScript" icon="newspaper" href="https://medium.com/javascript-in-plain-english/how-to-traverse-the-dom-in-javascript-d6555c335b4e">
    Vojislav Grujic's in-depth guide to DOM traversal with practical examples.
  </Card>
  <Card title="Render Tree Construction" icon="newspaper" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">
    Google's authoritative guide to how browsers construct the render tree from DOM and CSSOM.
  </Card>
  <Card title="What, exactly, is the DOM?" icon="newspaper" href="https://bitsofco.de/what-exactly-is-the-dom/">
    Ire Aderinokun's excellent breakdown of what the DOM is and isn't, including how it differs from the render tree.
  </Card>
  <Card title="JavaScript DOM Tutorial" icon="newspaper" href="https://www.javascripttutorial.net/javascript-dom/">
    A comprehensive multi-part tutorial covering selection, traversal, manipulation, and events.
  </Card>
</CardGroup>

## Courses

<Card title="JavaScript DOM Manipulation â€“ Full Course for Beginners" icon="graduation-cap" href="https://www.youtube.com/watch?v=5fb2aPlgoys">
  A comprehensive freeCodeCamp course covering DOM selection, traversal, manipulation, and events from the ground up.
</Card>

## Videos

<CardGroup cols={2}>
  <Card title="JavaScript DOM Tutorial" icon="video" href="https://www.youtube.com/watch?v=FIORjGvT0kk">
    The Net Ninja's popular playlist covering DOM fundamentals step by step.
  </Card>
  <Card title="JavaScript DOM Crash Course" icon="video" href="https://www.youtube.com/watch?v=0ik6X4DJKCc">
    Traversy Media's comprehensive crash course covering DOM manipulation in one video.
  </Card>
  <Card title="JavaScript DOM Manipulation Methods" icon="video" href="https://www.youtube.com/watch?v=y17RuWkWdn8">
    Web Dev Simplified explains createElement, appendChild, and other manipulation methods.
  </Card>
  <Card title="JavaScript DOM Traversal Methods" icon="video" href="https://www.youtube.com/watch?v=v7rSSy8CaYE">
    Web Dev Simplified covers parent, child, and sibling traversal methods.
  </Card>
</CardGroup>
